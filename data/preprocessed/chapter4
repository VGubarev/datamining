Chapter 4 Data Warehousing and Online Analytical Processing

systems and data warehouses (Section 4.1.2), then explain the need for using data warehouses for data analysis, rather than performing the analysis directly on traditional
databases (Section 4.1.3). This is followed by a presentation of data warehouse architecture (Section 4.1.4). Next, we study three data warehouse models—an enterprise model,
a data mart, and a virtual warehouse (Section 4.1.5). Section 4.1.6 describes back-end
utilities for data warehousing, such as extraction, transformation, and loading. Finally,
Section 4.1.7 presents the metadata repository, which stores data about data.

4.1.1 What Is a Data Warehouse?
Data warehousing provides architectures and tools for business executives to systematically organize, understand, and use their data to make strategic decisions. Data
warehouse systems are valuable tools in today’s competitive, fast-evolving world. In the
last several years, many firms have spent millions of dollars in building enterprise-wide
data warehouses. Many people feel that with competition mounting in every industry,
data warehousing is the latest must-have marketing weapon—a way to retain customers
by learning more about their needs.
“Then, what exactly is a data warehouse?” Data warehouses have been defined in many
ways, making it difficult to formulate a rigorous definition. Loosely speaking, a data
warehouse refers to a data repository that is maintained separately from an organization’s operational databases. Data warehouse systems allow for integration of a variety of
application systems. They support information processing by providing a solid platform
of consolidated historic data for analysis.
According to William H. Inmon, a leading architect in the construction of data
warehouse systems, “A data warehouse is a subject-oriented, integrated, time-variant,
and nonvolatile collection of data in support of management’s decision making process” [Inm96]. This short but comprehensive definition presents the major features of
a data warehouse. The four keywords—subject-oriented, integrated, time-variant, and
nonvolatile—distinguish data warehouses from other data repository systems, such as
relational database systems, transaction processing systems, and file systems.
Let’s take a closer look at each of these key features.
Subject-oriented: A data warehouse is organized around major subjects such as customer, supplier, product, and sales. Rather than concentrating on the day-to-day
operations and transaction processing of an organization, a data warehouse focuses
on the modeling and analysis of data for decision makers. Hence, data warehouses
typically provide a simple and concise view of particular subject issues by excluding
data that are not useful in the decision support process.
Integrated: A data warehouse is usually constructed by integrating multiple heterogeneous sources, such as relational databases, flat files, and online transaction
records. Data cleaning and data integration techniques are applied to ensure consistency in naming conventions, encoding structures, attribute measures, and so on.

4.1 Data Warehouse: Basic Concepts

127

Time-variant: Data are stored to provide information from an historic perspective
(e.g., the past 5–10 years). Every key structure in the data warehouse contains, either
implicitly or explicitly, a time element.
Nonvolatile: A data warehouse is always a physically separate store of data transformed from the application data found in the operational environment. Due to
this separation, a data warehouse does not require transaction processing, recovery,
and concurrency control mechanisms. It usually requires only two operations in data
accessing: initial loading of data and access of data.
In sum, a data warehouse is a semantically consistent data store that serves as a
physical implementation of a decision support data model. It stores the information
an enterprise needs to make strategic decisions. A data warehouse is also often viewed
as an architecture, constructed by integrating data from multiple heterogeneous sources
to support structured and/or ad hoc queries, analytical reporting, and decision making.
Based on this information, we view data warehousing as the process of constructing and using data warehouses. The construction of a data warehouse requires data
cleaning, data integration, and data consolidation. The utilization of a data warehouse
often necessitates a collection of decision support technologies. This allows “knowledge
workers” (e.g., managers, analysts, and executives) to use the warehouse to quickly and
conveniently obtain an overview of the data, and to make sound decisions based on
information in the warehouse. Some authors use the term data warehousing to refer
only to the process of data warehouse construction, while the term warehouse DBMS is
used to refer to the management and utilization of data warehouses. We will not make
this distinction here.
“How are organizations using the information from data warehouses?” Many organizations use this information to support business decision-making activities, including (1) increasing customer focus, which includes the analysis of customer buying
patterns (such as buying preference, buying time, budget cycles, and appetites for
spending); (2) repositioning products and managing product portfolios by comparing the performance of sales by quarter, by year, and by geographic regions in order
to fine-tune production strategies; (3) analyzing operations and looking for sources of
profit; and (4) managing customer relationships, making environmental corrections,
and managing the cost of corporate assets.
Data warehousing is also very useful from the point of view of heterogeneous database
integration. Organizations typically collect diverse kinds of data and maintain large
databases from multiple, heterogeneous, autonomous, and distributed information
sources. It is highly desirable, yet challenging, to integrate such data and provide easy
and efficient access to it. Much effort has been spent in the database industry and
research community toward achieving this goal.
The traditional database approach to heterogeneous database integration is to build
wrappers and integrators (or mediators) on top of multiple, heterogeneous databases.
When a query is posed to a client site, a metadata dictionary is used to translate the
query into queries appropriate for the individual heterogeneous sites involved. These

128

Chapter 4 Data Warehousing and Online Analytical Processing

queries are then mapped and sent to local query processors. The results returned from
the different sites are integrated into a global answer set. This query-driven approach
requires complex information filtering and integration processes, and competes with
local sites for processing resources. It is inefficient and potentially expensive for frequent
queries, especially queries requiring aggregations.
Data warehousing provides an interesting alternative to this traditional approach.
Rather than using a query-driven approach, data warehousing employs an updatedriven approach in which information from multiple, heterogeneous sources is integrated in advance and stored in a warehouse for direct querying and analysis. Unlike
online transaction processing databases, data warehouses do not contain the most current information. However, a data warehouse brings high performance to the integrated
heterogeneous database system because data are copied, preprocessed, integrated, annotated, summarized, and restructured into one semantic data store. Furthermore, query
processing in data warehouses does not interfere with the processing at local sources.
Moreover, data warehouses can store and integrate historic information and support
complex multidimensional queries. As a result, data warehousing has become popular
in industry.

4.1.2 Differences between Operational Database Systems
and Data Warehouses
Because most people are familiar with commercial relational database systems, it is easy
to understand what a data warehouse is by comparing these two kinds of systems.
The major task of online operational database systems is to perform online transaction and query processing. These systems are called online transaction processing
(OLTP) systems. They cover most of the day-to-day operations of an organization such
as purchasing, inventory, manufacturing, banking, payroll, registration, and accounting. Data warehouse systems, on the other hand, serve users or knowledge workers in
the role of data analysis and decision making. Such systems can organize and present
data in various formats in order to accommodate the diverse needs of different users.
These systems are known as online analytical processing (OLAP) systems.
The major distinguishing features of OLTP and OLAP are summarized as follows:
Users and system orientation: An OLTP system is customer-oriented and is used
for transaction and query processing by clerks, clients, and information technology
professionals. An OLAP system is market-oriented and is used for data analysis by
knowledge workers, including managers, executives, and analysts.
Data contents: An OLTP system manages current data that, typically, are too detailed
to be easily used for decision making. An OLAP system manages large amounts of
historic data, provides facilities for summarization and aggregation, and stores and
manages information at different levels of granularity. These features make the data
easier to use for informed decision making.

4.1 Data Warehouse: Basic Concepts

129

Database design: An OLTP system usually adopts an entity-relationship (ER) data
model and an application-oriented database design. An OLAP system typically
adopts either a star or a snowflake model (see Section 4.2.2) and a subject-oriented
database design.
View: An OLTP system focuses mainly on the current data within an enterprise or
department, without referring to historic data or data in different organizations. In
contrast, an OLAP system often spans multiple versions of a database schema, due to
the evolutionary process of an organization. OLAP systems also deal with information that originates from different organizations, integrating information from many
data stores. Because of their huge volume, OLAP data are stored on multiple storage
media.
Access patterns: The access patterns of an OLTP system consist mainly of short,
atomic transactions. Such a system requires concurrency control and recovery mechanisms. However, accesses to OLAP systems are mostly read-only operations (because
most data warehouses store historic rather than up-to-date information), although
many could be complex queries.
Other features that distinguish between OLTP and OLAP systems include database
size, frequency of operations, and performance metrics. These are summarized in
Table 4.1.

4.1.3 But, Why Have a Separate Data Warehouse?
Because operational databases store huge amounts of data, you may wonder, “Why not
perform online analytical processing directly on such databases instead of spending additional time and resources to construct a separate data warehouse?” A major reason for such
a separation is to help promote the high performance of both systems. An operational
database is designed and tuned from known tasks and workloads like indexing and
hashing using primary keys, searching for particular records, and optimizing “canned”
queries. On the other hand, data warehouse queries are often complex. They involve the
computation of large data groups at summarized levels, and may require the use of special data organization, access, and implementation methods based on multidimensional
views. Processing OLAP queries in operational databases would substantially degrade
the performance of operational tasks.
Moreover, an operational database supports the concurrent processing of multiple
transactions. Concurrency control and recovery mechanisms (e.g., locking and logging)
are required to ensure the consistency and robustness of transactions. An OLAP query
often needs read-only access of data records for summarization and aggregation. Concurrency control and recovery mechanisms, if applied for such OLAP operations, may
jeopardize the execution of concurrent transactions and thus substantially reduce the
throughput of an OLTP system.
Finally, the separation of operational databases from data warehouses is based on
the different structures, contents, and uses of the data in these two systems. Decision

130

Chapter 4 Data Warehousing and Online Analytical Processing

Table 4.1 Comparison of OLTP and OLAP Systems
Feature

OLTP

OLAP

Characteristic
Orientation
User

operational processing
transaction
clerk, DBA, database professional

Function

day-to-day operations

DB design
Data

ER-based, application-oriented
current, guaranteed up-to-date

Summarization
View
Unit of work
Access
Focus
Operations
Number of records
accessed
Number of users
DB size
Priority
Metric

primitive, highly detailed
detailed, flat relational
short, simple transaction
read/write
data in
index/hash on primary key

informational processing
analysis
knowledge worker (e.g., manager,
executive, analyst)
long-term informational
requirements decision support
star/snowflake, subject-oriented
historic, accuracy maintained
over time
summarized, consolidated
summarized, multidimensional
complex query
mostly read
information out
lots of scans

tens
thousands
GB to high-order GB
high performance, high availability
transaction throughput

millions
hundreds
≥ TB
high flexibility, end-user autonomy
query throughput, response time

Note: Table is partially based on Chaudhuri and Dayal [CD97].

support requires historic data, whereas operational databases do not typically maintain
historic data. In this context, the data in operational databases, though abundant, are
usually far from complete for decision making. Decision support requires consolidation
(e.g., aggregation and summarization) of data from heterogeneous sources, resulting
in high-quality, clean, integrated data. In contrast, operational databases contain only
detailed raw data, such as transactions, which need to be consolidated before analysis. Because the two systems provide quite different functionalities and require different
kinds of data, it is presently necessary to maintain separate databases. However, many
vendors of operational relational database management systems are beginning to optimize such systems to support OLAP queries. As this trend continues, the separation
between OLTP and OLAP systems is expected to decrease.

4.1.4 Data Warehousing: A Multitiered Architecture
Data warehouses often adopt a three-tier architecture, as presented in Figure 4.1.

4.1 Data Warehouse: Basic Concepts

Query/report

Analysis

131

Data mining

Top tier:
Front-end tools

Output
OLAP server

OLAP server
Middle tier:
OLAP server

Monitoring

Administration

Data warehouse

Data marts
Bottom tier:
Data warehouse
server

Metadata repository

Extract
Clean
Transform
Load
Refresh

Operational databases

Data

External sources

Figure 4.1 A three-tier data warehousing architecture.

1. The bottom tier is a warehouse database server that is almost always a relational
database system. Back-end tools and utilities are used to feed data into the bottom tier from operational databases or other external sources (e.g., customer profile
information provided by external consultants). These tools and utilities perform data
extraction, cleaning, and transformation (e.g., to merge similar data from different
sources into a unified format), as well as load and refresh functions to update the
data warehouse (see Section 4.1.6). The data are extracted using application program interfaces known as gateways. A gateway is supported by the underlying DBMS
and allows client programs to generate SQL code to be executed at a server. Examples of gateways include ODBC (Open Database Connection) and OLEDB (Object

132

Chapter 4 Data Warehousing and Online Analytical Processing

Linking and Embedding Database) by Microsoft and JDBC (Java Database Connection). This tier also contains a metadata repository, which stores information about
the data warehouse and its contents. The metadata repository is further described in
Section 4.1.7.
2. The middle tier is an OLAP server that is typically implemented using either (1) a
relational OLAP (ROLAP) model (i.e., an extended relational DBMS that maps operations on multidimensional data to standard relational operations); or (2) a multidimensional OLAP (MOLAP) model (i.e., a special-purpose server that directly
implements multidimensional data and operations). OLAP servers are discussed in
Section 4.4.4.
3. The top tier is a front-end client layer, which contains query and reporting tools,
analysis tools, and/or data mining tools (e.g., trend analysis, prediction, and so on).

4.1.5 Data Warehouse Models: Enterprise Warehouse,
Data Mart, and Virtual Warehouse
From the architecture point of view, there are three data warehouse models: the
enterprise warehouse, the data mart, and the virtual warehouse.
Enterprise warehouse: An enterprise warehouse collects all of the information about
subjects spanning the entire organization. It provides corporate-wide data integration, usually from one or more operational systems or external information
providers, and is cross-functional in scope. It typically contains detailed data as
well as summarized data, and can range in size from a few gigabytes to hundreds
of gigabytes, terabytes, or beyond. An enterprise data warehouse may be implemented on traditional mainframes, computer superservers, or parallel architecture
platforms. It requires extensive business modeling and may take years to design
and build.
Data mart: A data mart contains a subset of corporate-wide data that is of value to a
specific group of users. The scope is confined to specific selected subjects. For example, a marketing data mart may confine its subjects to customer, item, and sales. The
data contained in data marts tend to be summarized.
Data marts are usually implemented on low-cost departmental servers that are
Unix/Linux or Windows based. The implementation cycle of a data mart is more
likely to be measured in weeks rather than months or years. However, it may
involve complex integration in the long run if its design and planning were not
enterprise-wide.
Depending on the source of data, data marts can be categorized as independent
or dependent. Independent data marts are sourced from data captured from one or
more operational systems or external information providers, or from data generated
locally within a particular department or geographic area. Dependent data marts are
sourced directly from enterprise data warehouses.

4.1 Data Warehouse: Basic Concepts

133

Virtual warehouse: A virtual warehouse is a set of views over operational databases.
For efficient query processing, only some of the possible summary views may be
materialized. A virtual warehouse is easy to build but requires excess capacity on
operational database servers.
“What are the pros and cons of the top-down and bottom-up approaches to data warehouse development?” The top-down development of an enterprise warehouse serves as a
systematic solution and minimizes integration problems. However, it is expensive, takes
a long time to develop, and lacks flexibility due to the difficulty in achieving consistency
and consensus for a common data model for the entire organization. The bottomup approach to the design, development, and deployment of independent data marts
provides flexibility, low cost, and rapid return of investment. It, however, can lead to
problems when integrating various disparate data marts into a consistent enterprise data
warehouse.
A recommended method for the development of data warehouse systems is to implement the warehouse in an incremental and evolutionary manner, as shown in Figure 4.2.
First, a high-level corporate data model is defined within a reasonably short period
(such as one or two months) that provides a corporate-wide, consistent, integrated
view of data among different subjects and potential usages. This high-level model,
although it will need to be refined in the further development of enterprise data warehouses and departmental data marts, will greatly reduce future integration problems.
Second, independent data marts can be implemented in parallel with the enterprise

Multitier
data
warehouse

Distributed
data marts

Data
mart

Enterprise
data
warehouse

Data
mart

Model refinement

Model refinement

Define a high-level corporate data model

Figure 4.2 A recommended approach for data warehouse development.

134

Chapter 4 Data Warehousing and Online Analytical Processing

warehouse based on the same corporate data model set noted before. Third, distributed
data marts can be constructed to integrate different data marts via hub servers. Finally,
a multitier data warehouse is constructed where the enterprise warehouse is the sole
custodian of all warehouse data, which is then distributed to the various dependent
data marts.

4.1.6 Extraction, Transformation, and Loading
Data warehouse systems use back-end tools and utilities to populate and refresh their
data (Figure 4.1). These tools and utilities include the following functions:
Data extraction, which typically gathers data from multiple, heterogeneous, and
external sources.
Data cleaning, which detects errors in the data and rectifies them when possible.
Data transformation, which converts data from legacy or host format to warehouse
format.
Load, which sorts, summarizes, consolidates, computes views, checks integrity, and
builds indices and partitions.
Refresh, which propagates the updates from the data sources to the warehouse.
Besides cleaning, loading, refreshing, and metadata definition tools, data warehouse
systems usually provide a good set of data warehouse management tools.
Data cleaning and data transformation are important steps in improving the data
quality and, subsequently, the data mining results (see Chapter 3). Because we are mostly
interested in the aspects of data warehousing technology related to data mining, we will
not get into the details of the remaining tools, and recommend interested readers to
consult books dedicated to data warehousing technology.

4.1.7 Metadata Repository
Metadata are data about data. When used in a data warehouse, metadata are the data
that define warehouse objects. Figure 4.1 showed a metadata repository within the bottom tier of the data warehousing architecture. Metadata are created for the data names
and definitions of the given warehouse. Additional metadata are created and captured
for timestamping any extracted data, the source of the extracted data, and missing fields
that have been added by data cleaning or integration processes.
A metadata repository should contain the following:
A description of the data warehouse structure, which includes the warehouse schema,
view, dimensions, hierarchies, and derived data definitions, as well as data mart
locations and contents.

4.2 Data Warehouse Modeling: Data Cube and OLAP

135

Operational metadata, which include data lineage (history of migrated data and the
sequence of transformations applied to it), currency of data (active, archived, or
purged), and monitoring information (warehouse usage statistics, error reports, and
audit trails).
The algorithms used for summarization, which include measure and dimension
definition algorithms, data on granularity, partitions, subject areas, aggregation,
summarization, and predefined queries and reports.
Mapping from the operational environment to the data warehouse, which includes
source databases and their contents, gateway descriptions, data partitions, data
extraction, cleaning, transformation rules and defaults, data refresh and purging
rules, and security (user authorization and access control).
Data related to system performance, which include indices and profiles that improve
data access and retrieval performance, in addition to rules for the timing and
scheduling of refresh, update, and replication cycles.
Business metadata, which include business terms and definitions, data ownership
information, and charging policies.
A data warehouse contains different levels of summarization, of which metadata is one.
Other types include current detailed data (which are almost always on disk), older
detailed data (which are usually on tertiary storage), lightly summarized data, and highly
summarized data (which may or may not be physically housed).
Metadata play a very different role than other data warehouse data and are important
for many reasons. For example, metadata are used as a directory to help the decision
support system analyst locate the contents of the data warehouse, and as a guide to
the data mapping when data are transformed from the operational environment to the
data warehouse environment. Metadata also serve as a guide to the algorithms used for
summarization between the current detailed data and the lightly summarized data, and
between the lightly summarized data and the highly summarized data. Metadata should
be stored and managed persistently (i.e., on disk).

4.2

Data Warehouse Modeling: Data Cube
and OLAP
Data warehouses and OLAP tools are based on a multidimensional data model. This
model views data in the form of a data cube. In this section, you will learn how data cubes
model n-dimensional data (Section 4.2.1). In Section 4.2.2, various multidimensional
models are shown: star schema, snowflake schema, and fact constellation. You will also
learn about concept hierarchies (Section 4.2.3) and measures (Section 4.2.4) and how
they can be used in basic OLAP operations to allow interactive mining at multiple levels
of abstraction. Typical OLAP operations such as drill-down and roll-up are illustrated

136

Chapter 4 Data Warehousing and Online Analytical Processing

(Section 4.2.5). Finally, the starnet model for querying multidimensional databases is
presented (Section 4.2.6).

4.2.1 Data Cube: A Multidimensional Data Model
“What is a data cube?” A data cube allows data to be modeled and viewed in multiple
dimensions. It is defined by dimensions and facts.
In general terms, dimensions are the perspectives or entities with respect to which
an organization wants to keep records. For example, AllElectronics may create a sales
data warehouse in order to keep records of the store’s sales with respect to the dimensions time, item, branch, and location. These dimensions allow the store to keep track
of things like monthly sales of items and the branches and locations at which the
items were sold. Each dimension may have a table associated with it, called a dimension table, which further describes the dimension. For example, a dimension table for
item may contain the attributes item name, brand, and type. Dimension tables can be
specified by users or experts, or automatically generated and adjusted based on data
distributions.
A multidimensional data model is typically organized around a central theme, such
as sales. This theme is represented by a fact table. Facts are numeric measures. Think of
them as the quantities by which we want to analyze relationships between dimensions.
Examples of facts for a sales data warehouse include dollars sold (sales amount in dollars), units sold (number of units sold), and amount budgeted. The fact table contains
the names of the facts, or measures, as well as keys to each of the related dimension tables.
You will soon get a clearer picture of how this works when we look at multidimensional
schemas.
Although we usually think of cubes as 3-D geometric structures, in data warehousing the data cube is n-dimensional. To gain a better understanding of data cubes and
the multidimensional data model, let’s start by looking at a simple 2-D data cube that
is, in fact, a table or spreadsheet for sales data from AllElectronics. In particular, we
will look at the AllElectronics sales data for items sold per quarter in the city of Vancouver. These data are shown in Table 4.2. In this 2-D representation, the sales for
Vancouver are shown with respect to the time dimension (organized in quarters) and
the item dimension (organized according to the types of items sold). The fact or measure
displayed is dollars sold (in thousands).
Now, suppose that we would like to view the sales data with a third dimension. For
instance, suppose we would like to view the data according to time and item, as well as
location, for the cities Chicago, New York, Toronto, and Vancouver. These 3-D data are
shown in Table 4.3. The 3-D data in the table are represented as a series of 2-D tables.
Conceptually, we may also represent the same data in the form of a 3-D data cube, as in
Figure 4.3.
Suppose that we would now like to view our sales data with an additional fourth
dimension such as supplier. Viewing things in 4-D becomes tricky. However, we can
think of a 4-D cube as being a series of 3-D cubes, as shown in Figure 4.4. If we continue

4.2 Data Warehouse Modeling: Data Cube and OLAP

137

Table 4.2 2-D View of Sales Data for AllElectronics According to time and item
location = “Vancouver”
item (type)
time (quarter)

home
entertainment

computer

phone

security

Q1
Q2
Q3
Q4

605
680
812
927

825
952
1023
1038

14
31
30
38

400
512
501
580

Note: The sales are from branches located in the city of Vancouver. The measure displayed is dollars sold
(in thousands).

Table 4.3 3-D View of Sales Data for AllElectronics According to time, item, and location
location = “Chicago”
item

location = “New York”

location = “Toronto”

item

location = “Vancouver”

item

item

home
time ent. comp. phone sec.

home
ent. comp. phone sec.

home
ent. comp. phone sec.

home
ent. comp. phone sec.

Q1
Q2
Q3
Q4

1087 968 38
1130 1024 41
1034 1048 45
1142 1091 54

818
894
940
978

605
680
812
927

854
943
1032
1129

882
890
924
992

89
64
59
63

623
698
789
870

872
925
1002
984

746
769
795
864

43
52
58
59

591
682
728
784

825
952
1023
1038

14
31
30
38

400
512
501
580

Note: The measure displayed is dollars sold (in thousands).

in this way, we may display any n-dimensional data as a series of (n − 1)-dimensional
“cubes.” The data cube is a metaphor for multidimensional data storage. The actual
physical storage of such data may differ from its logical representation. The important
thing to remember is that data cubes are n-dimensional and do not confine data to 3-D.
Tables 4.2 and 4.3 show the data at different degrees of summarization. In the data
warehousing research literature, a data cube like those shown in Figures 4.3 and 4.4 is
often referred to as a cuboid. Given a set of dimensions, we can generate a cuboid for
each of the possible subsets of the given dimensions. The result would form a lattice of
cuboids, each showing the data at a different level of summarization, or group-by. The
lattice of cuboids is then referred to as a data cube. Figure 4.5 shows a lattice of cuboids
forming a data cube for the dimensions time, item, location, and supplier.
The cuboid that holds the lowest level of summarization is called the base cuboid.
For example, the 4-D cuboid in Figure 4.4 is the base cuboid for the given time, item,
location, and supplier dimensions. Figure 4.3 is a 3-D (nonbase) cuboid for time, item,

Chapter 4 Data Warehousing and Online Analytical Processing

n

io

t
ca

)
es

iti

(c

854

Chicago

882

New York
1087 968
Toronto
818
746
43
Vancouver
lo

time (quarters)

Q1
Q2

605
680

825

14

952

31

1023

30

501

Q4

927

1038

38

580

computer

623

25

2
68

512

812

89

38
872
591

400

Q3

home
entertainment

72

8

78

4

9

2

0
10

4
98

69

8

78

9

87

0

security
phone

item (types)

Figure 4.3 A 3-D data cube representation of the data in Table 4.3, according to time, item, and location.
The measure displayed is dollars sold (in thousands).

n

c
lo

)
es

iti

(c

Chicago
New York
Toronto
Vancouver

io
at

time (quarters)

138

supplier = “SUP1”

supplier = “SUP2”

supplier = “SUP3”

Q1 605 825 14 400
Q2
Q3
Q4
computer security
home
phone
entertainment

item (types)

computer security
home
phone
entertainment

item (types)

computer security
home
phone
entertainment

item (types)

Figure 4.4 A 4-D data cube representation of sales data, according to time, item, location, and supplier.
The measure displayed is dollars sold (in thousands). For improved readability, only some of
the cube values are shown.

and location, summarized for all suppliers. The 0-D cuboid, which holds the highest level
of summarization, is called the apex cuboid. In our example, this is the total sales, or
dollars sold, summarized over all four dimensions. The apex cuboid is typically denoted
by all.

4.2 Data Warehouse Modeling: Data Cube and OLAP

0-D (apex) cuboid

all

time

time, item

time, item, location

Item
item

location

time, supplier
time, location

139

item,
item, supplier
supplier

item, location

location,
supplier

time, item, location, supplier

2-D cuboids

3-D cuboids

time,
time, location,
location, supplier
time, item, supplier

1-D cuboids

supplier

item, location,
supplier

4-D (base) cuboid

Figure 4.5 Lattice of cuboids, making up a 4-D data cube for time, item, location, and supplier. Each
cuboid represents a different degree of summarization.

4.2.2 Stars, Snowflakes, and Fact Constellations: Schemas for
Multidimensional Data Models
The entity-relationship data model is commonly used in the design of relational
databases, where a database schema consists of a set of entities and the relationships
between them. Such a data model is appropriate for online transaction processing.
A data warehouse, however, requires a concise, subject-oriented schema that facilitates
online data analysis.
The most popular data model for a data warehouse is a multidimensional model,
which can exist in the form of a star schema, a snowflake schema, or a fact constellation
schema. Let’s look at each of these.
Star schema: The most common modeling paradigm is the star schema, in which the
data warehouse contains (1) a large central table (fact table) containing the bulk of
the data, with no redundancy, and (2) a set of smaller attendant tables (dimension
tables), one for each dimension. The schema graph resembles a starburst, with the
dimension tables displayed in a radial pattern around the central fact table.
Example 4.1 Star schema. A star schema for AllElectronics sales is shown in Figure 4.6. Sales are considered along four dimensions: time, item, branch, and location. The schema contains
a central fact table for sales that contains keys to each of the four dimensions, along

140

Chapter 4 Data Warehousing and Online Analytical Processing

time
Dimension table
time_key
day
day_of_the_week
month
quarter
year

sales
Fact table
time_key
item_key
branch_key
location_key
dollars_sold
units_sold

branch
Dimension table
branch_key
branch_name
branch_type

item
Dimension table
item_key
item_name
brand
type
supplier_type

location
Dimension table
location_key
street
city
province_or_state
country

Figure 4.6 Star schema of sales data warehouse.

with two measures: dollars sold and units sold. To minimize the size of the fact table,
dimension identifiers (e.g., time key and item key) are system-generated identifiers.
Notice that in the star schema, each dimension is represented by only one table, and
each table contains a set of attributes. For example, the location dimension table contains
the attribute set {location key, street, city, province or state, country}. This constraint may
introduce some redundancy. For example, “Urbana” and “Chicago” are both cities in the
state of Illinois, USA. Entries for such cities in the location dimension table will create
redundancy among the attributes province or state and country; that is, (..., Urbana, IL,
USA) and (..., Chicago, IL, USA). Moreover, the attributes within a dimension table may
form either a hierarchy (total order) or a lattice (partial order).
Snowflake schema: The snowflake schema is a variant of the star schema model,
where some dimension tables are normalized, thereby further splitting the data into
additional tables. The resulting schema graph forms a shape similar to a snowflake.
The major difference between the snowflake and star schema models is that the
dimension tables of the snowflake model may be kept in normalized form to reduce
redundancies. Such a table is easy to maintain and saves storage space. However, this
space savings is negligible in comparison to the typical magnitude of the fact table. Furthermore, the snowflake structure can reduce the effectiveness of browsing, since more
joins will be needed to execute a query. Consequently, the system performance may be
adversely impacted. Hence, although the snowflake schema reduces redundancy, it is not
as popular as the star schema in data warehouse design.

4.2 Data Warehouse Modeling: Data Cube and OLAP

time
Dimension table
time_key
day
day_of_week
month
quarter
year

sales
Fact table
time_key
item_key
branch_key
location_key
dollars_sold
units_sold

branch
Dimension table
branch_key
branch_name
branch_type

item
Dimension table

supplier
Dimension table

item_key
item_name
brand
type
supplier_key

supplier_key
supplier_type

141

location
Dimension table
location_key
street
city_key

city
Dimension table
city_key
city
province_or_state
country

Figure 4.7 Snowflake schema of a sales data warehouse.

Example 4.2 Snowflake schema. A snowflake schema for AllElectronics sales is given in Figure 4.7.
Here, the sales fact table is identical to that of the star schema in Figure 4.6. The
main difference between the two schemas is in the definition of dimension tables.
The single dimension table for item in the star schema is normalized in the snowflake
schema, resulting in new item and supplier tables. For example, the item dimension
table now contains the attributes item key, item name, brand, type, and supplier key,
where supplier key is linked to the supplier dimension table, containing supplier key and
supplier type information. Similarly, the single dimension table for location in the star
schema can be normalized into two new tables: location and city. The city key in the
new location table links to the city dimension. Notice that, when desirable, further normalization can be performed on province or state and country in the snowflake schema
shown in Figure 4.7.
Fact constellation: Sophisticated applications may require multiple fact tables to share
dimension tables. This kind of schema can be viewed as a collection of stars, and
hence is called a galaxy schema or a fact constellation.

Example 4.3 Fact constellation. A fact constellation schema is shown in Figure 4.8. This schema
specifies two fact tables, sales and shipping. The sales table definition is identical to that of
the star schema (Figure 4.6). The shipping table has five dimensions, or keys—item key,
time key, shipper key, from location, and to location—and two measures—dollars cost

142

Chapter 4 Data Warehousing and Online Analytical Processing

time
Dimension table
time_key
day
day_of_week
month
quarter
year

branch
Dimension table
branch_key
branch_name
branch_type

sales
Fact table
time_key
item_key
branch_key
location_key
dollars_sold
units_sold

item
Dimension table
item_key
item_name
brand
type
supplier_type

shipping
Fact table
item_key
time_key
shipper_key
from_location
to_location
dollars_cost
units_shipped

shipper
Dimension table
shipper_key
shipper_name
location_key
shipper_type

location
Dimension table
location_key
street
city
province_or_state
country

Figure 4.8 Fact constellation schema of a sales and shipping data warehouse.

and units shipped. A fact constellation schema allows dimension tables to be shared
between fact tables. For example, the dimensions tables for time, item, and location are
shared between the sales and shipping fact tables.
In data warehousing, there is a distinction between a data warehouse and a data mart.
A data warehouse collects information about subjects that span the entire organization,
such as customers, items, sales, assets, and personnel, and thus its scope is enterprise-wide.
For data warehouses, the fact constellation schema is commonly used, since it can model
multiple, interrelated subjects. A data mart, on the other hand, is a department subset of
the data warehouse that focuses on selected subjects, and thus its scope is departmentwide. For data marts, the star or snowflake schema is commonly used, since both are
geared toward modeling single subjects, although the star schema is more popular and
efficient.

4.2.3 Dimensions: The Role of Concept Hierarchies
A concept hierarchy defines a sequence of mappings from a set of low-level concepts
to higher-level, more general concepts. Consider a concept hierarchy for the dimension
location. City values for location include Vancouver, Toronto, New York, and Chicago.
Each city, however, can be mapped to the province or state to which it belongs. For
example, Vancouver can be mapped to British Columbia, and Chicago to Illinois.
The provinces and states can in turn be mapped to the country (e.g., Canada or the
United States) to which they belong. These mappings form a concept hierarchy for the

4.2 Data Warehouse Modeling: Data Cube and OLAP

143

dimension location, mapping a set of low-level concepts (i.e., cities) to higher-level, more
general concepts (i.e., countries). This concept hierarchy is illustrated in Figure 4.9.
Many concept hierarchies are implicit within the database schema. For example,
suppose that the dimension location is described by the attributes number, street, city,
province or state, zip code, and country. These attributes are related by a total order,
forming a concept hierarchy such as “street < city < province or state < country.” This
hierarchy is shown in Figure 4.10(a). Alternatively, the attributes of a dimension may
location
all

all

country

province_
or_state

city

Canada

British Columbia

Vancouver

USA

Ontario

Victoria

Toronto

New York

Ottawa

New York

Buffalo

Illinois

Chicago

Urbana

Figure 4.9 A concept hierarchy for location. Due to space limitations, not all of the hierarchy nodes are
shown, indicated by ellipses between nodes.
country
year

province_or_state

quarter

city

month

week

street

day

(a)

(b)

Figure 4.10 Hierarchical and lattice structures of attributes in warehouse dimensions: (a) a hierarchy for
location and (b) a lattice for time.

144

Chapter 4 Data Warehousing and Online Analytical Processing

($0 $1000]

($0 $200]

($0 …
$100]

($100…
$200]

($200 $400]

($200…
$300]

($300…
$400]

($400 $600]

($600 $800]

($400… ($500… ($600…
$500]
$600]
$700]

($800 $1000]

($700… ($800…
$800]
$900]

($900…
$1000]

Figure 4.11 A concept hierarchy for price.

be organized in a partial order, forming a lattice. An example of a partial order for the
time dimension based on the attributes day, week, month, quarter, and year is “day <
{month < quarter; week} < year.”1 This lattice structure is shown in Figure 4.10(b).
A concept hierarchy that is a total or partial order among attributes in a database schema
is called a schema hierarchy. Concept hierarchies that are common to many applications (e.g., for time) may be predefined in the data mining system. Data mining systems
should provide users with the flexibility to tailor predefined hierarchies according to
their particular needs. For example, users may want to define a fiscal year starting on
April 1 or an academic year starting on September 1.
Concept hierarchies may also be defined by discretizing or grouping values for a
given dimension or attribute, resulting in a set-grouping hierarchy. A total or partial
order can be defined among groups of values. An example of a set-grouping hierarchy is
shown in Figure 4.11 for the dimension price, where an interval ($X . . . $Y ] denotes the
range from $X (exclusive) to $Y (inclusive).
There may be more than one concept hierarchy for a given attribute or dimension,
based on different user viewpoints. For instance, a user may prefer to organize price by
defining ranges for inexpensive, moderately priced, and expensive.
Concept hierarchies may be provided manually by system users, domain experts, or
knowledge engineers, or may be automatically generated based on statistical analysis of
the data distribution. The automatic generation of concept hierarchies is discussed in
Chapter 3 as a preprocessing step in preparation for data mining.
Concept hierarchies allow data to be handled at varying levels of abstraction, as we
will see in Section 4.2.4.

4.2.4 Measures: Their Categorization and Computation
“How are measures computed?” To answer this question, we first study how measures can
be categorized. Note that a multidimensional point in the data cube space can be defined
1 Since a week often crosses the boundary of two consecutive months, it is usually not treated as a lower
abstraction of month. Instead, it is often treated as a lower abstraction of year, since a year contains
approximately 52 weeks.

4.2 Data Warehouse Modeling: Data Cube and OLAP

145

by a set of dimension–value pairs; for example, htime = “Q1”, location = “Vancouver”,
item = “computer”i. A data cube measure is a numeric function that can be evaluated
at each point in the data cube space. A measure value is computed for a given point by
aggregating the data corresponding to the respective dimension–value pairs defining the
given point. We will look at concrete examples of this shortly.
Measures can be organized into three categories—distributive, algebraic, and holistic—based on the kind of aggregate functions used.
Distributive: An aggregate function is distributive if it can be computed in a distributed
manner as follows. Suppose the data are partitioned into n sets. We apply the function to each partition, resulting in n aggregate values. If the result derived by applying
the function to the n aggregate values is the same as that derived by applying the function to the entire data set (without partitioning), the function can be computed in a
distributed manner. For example, sum() can be computed for a data cube by first partitioning the cube into a set of subcubes, computing sum() for each subcube, and then
summing up the counts obtained for each subcube. Hence, sum() is a distributive
aggregate function.
For the same reason, count(), min(), and max() are distributive aggregate functions.
By treating the count value of each nonempty base cell as 1 by default, count() of any
cell in a cube can be viewed as the sum of the count values of all of its corresponding
child cells in its subcube. Thus, count() is distributive. A measure is distributive if it is
obtained by applying a distributive aggregate function. Distributive measures can be
computed efficiently because of the way the computation can be partitioned.
Algebraic: An aggregate function is algebraic if it can be computed by an algebraic function with M arguments (where M is a bounded positive integer), each of which
is obtained by applying a distributive aggregate function. For example, avg() (average) can be computed by sum()/count(), where both sum() and count() are distributive
aggregate functions. Similarly, it can be shown that min N() and max N() (which
find the N minimum and N maximum values, respectively, in a given set) and
standard deviation() are algebraic aggregate functions. A measure is algebraic if it is
obtained by applying an algebraic aggregate function.
Holistic: An aggregate function is holistic if there is no constant bound on the storage size needed to describe a subaggregate. That is, there does not exist an algebraic
function with M arguments (where M is a constant) that characterizes the computation. Common examples of holistic functions include median(), mode(), and rank().
A measure is holistic if it is obtained by applying a holistic aggregate function.
Most large data cube applications require efficient computation of distributive and
algebraic measures. Many efficient techniques for this exist. In contrast, it is difficult to
compute holistic measures efficiently. Efficient techniques to approximate the computation of some holistic measures, however, do exist. For example, rather than computing
the exact median(), Equation (2.3) of Chapter 2 can be used to estimate the approximate median value for a large data set. In many cases, such techniques are sufficient to
overcome the difficulties of efficient computation of holistic measures.

146

Chapter 4 Data Warehousing and Online Analytical Processing

Various methods for computing different measures in data cube construction are
discussed in depth in Chapter 5. Notice that most of the current data cube technology confines the measures of multidimensional databases to numeric data. However,
measures can also be applied to other kinds of data, such as spatial, multimedia, or
text data.

4.2.5 Typical OLAP Operations
“How are concept hierarchies useful in OLAP?” In the multidimensional model, data are
organized into multiple dimensions, and each dimension contains multiple levels of
abstraction defined by concept hierarchies. This organization provides users with the
flexibility to view data from different perspectives. A number of OLAP data cube operations exist to materialize these different views, allowing interactive querying and analysis
of the data at hand. Hence, OLAP provides a user-friendly environment for interactive
data analysis.
Example 4.4 OLAP operations. Let’s look at some typical OLAP operations for multidimensional
data. Each of the following operations described is illustrated in Figure 4.12. At the center of the figure is a data cube for AllElectronics sales. The cube contains the dimensions
location, time, and item, where location is aggregated with respect to city values, time is
aggregated with respect to quarters, and item is aggregated with respect to item types.
To aid in our explanation, we refer to this cube as the central cube. The measure displayed is dollars sold (in thousands). (For improved readability, only some of the cubes’
cell values are shown.) The data examined are for the cities Chicago, New York, Toronto,
and Vancouver.
Roll-up: The roll-up operation (also called the drill-up operation by some vendors)
performs aggregation on a data cube, either by climbing up a concept hierarchy for
a dimension or by dimension reduction. Figure 4.12 shows the result of a roll-up
operation performed on the central cube by climbing up the concept hierarchy for
location given in Figure 4.9. This hierarchy was defined as the total order “street <
city < province or state < country.” The roll-up operation shown aggregates the data
by ascending the location hierarchy from the level of city to the level of country. In
other words, rather than grouping the data by city, the resulting cube groups the data
by country.
When roll-up is performed by dimension reduction, one or more dimensions are
removed from the given cube. For example, consider a sales data cube containing
only the location and time dimensions. Roll-up may be performed by removing, say,
the time dimension, resulting in an aggregation of the total sales by location, rather
than by location and by time.
Drill-down: Drill-down is the reverse of roll-up. It navigates from less detailed data
to more detailed data. Drill-down can be realized by either stepping down a concept
hierarchy for a dimension or introducing additional dimensions. Figure 4.12 shows the
result of a drill-down operation performed on the central cube by stepping down a

4.2 Data Warehouse Modeling: Data Cube and OLAP

s)

rie

t
un

time
(quarters)

lo

USA 2000
o
(c Canada
time (quarters)

ca

)
es
iti
(c
Toronto 395
n
tio Vancouver
ca
o
l
Q1 605

n

tio

Q2
computer
home
entertainment
item (types)

Q3
Q4

roll-up
on location
(from cities
to countries)

)

es

iti

Q2

computer security
phone
home
entertainment
item (types)

dice for
(location = “Toronto” or “Vancouver”)
and (time = “Q1” or “Q2”) and
(item = “home entertainment” or “computer”)

(c

Q1 1000

Toronto
605 825 14 400

computer security
home
phone
entertainment
item (types)

item (types)

pivot
home
entertainment
computer

14

400

Q2
Q3

605
825

phone

14

security

400
New York Vancouver
Chicago Toronto
location (cities)

drill-down
on time
(from quarters
to months)

Q4
computer security
home
phone
entertainment
item (types)

Chicago
New York

Vancouver

Q1 605 825

)
es
iti
(c NewChicago
York
n
tio
Toronto
ca
lo Vancouver
January
February
March
April
May
June
July
August
September
October
November
December

150
100
150

time (months)

location (cities)

slice
for time = “Q1”

time (quarters)

Chicago 440
n New York 1560
tio Toronto
a
395
c
lo Vancouver

computer security
home
phone
entertainment
item (types)

Figure 4.12 Examples of typical OLAP operations on multidimensional data.

147

148

Chapter 4 Data Warehousing and Online Analytical Processing

concept hierarchy for time defined as “day < month < quarter < year.” Drill-down
occurs by descending the time hierarchy from the level of quarter to the more detailed
level of month. The resulting data cube details the total sales per month rather than
summarizing them by quarter.
Because a drill-down adds more detail to the given data, it can also be performed by adding new dimensions to a cube. For example, a drill-down on the
central cube of Figure 4.12 can occur by introducing an additional dimension, such
as customer group.
Slice and dice: The slice operation performs a selection on one dimension of the given
cube, resulting in a subcube. Figure 4.12 shows a slice operation where the sales
data are selected from the central cube for the dimension time using the criterion
time = “Q1.” The dice operation defines a subcube by performing a selection on two
or more dimensions. Figure 4.12 shows a dice operation on the central cube based on
the following selection criteria that involve three dimensions: (location = “Toronto”
or “Vancouver”) and (time = “Q1” or “Q2”) and (item = “home entertainment” or
“computer”).
Pivot (rotate): Pivot (also called rotate) is a visualization operation that rotates the data
axes in view to provide an alternative data presentation. Figure 4.12 shows a pivot
operation where the item and location axes in a 2-D slice are rotated. Other examples
include rotating the axes in a 3-D cube, or transforming a 3-D cube into a series of
2-D planes.
Other OLAP operations: Some OLAP systems offer additional drilling operations. For
example, drill-across executes queries involving (i.e., across) more than one fact
table. The drill-through operation uses relational SQL facilities to drill through the
bottom level of a data cube down to its back-end relational tables.
Other OLAP operations may include ranking the top N or bottom N items in
lists, as well as computing moving averages, growth rates, interests, internal return
rates, depreciation, currency conversions, and statistical functions.
OLAP offers analytical modeling capabilities, including a calculation engine for
deriving ratios, variance, and so on, and for computing measures across multiple dimensions. It can generate summarizations, aggregations, and hierarchies at each granularity
level and at every dimension intersection. OLAP also supports functional models for
forecasting, trend analysis, and statistical analysis. In this context, an OLAP engine is a
powerful data analysis tool.

OLAP Systems versus Statistical Databases
Many OLAP systems’ characteristics (e.g., the use of a multidimensional data model
and concept hierarchies, the association of measures with dimensions, and the notions
of roll-up and drill-down) also exist in earlier work on statistical databases (SDBs).
A statistical database is a database system that is designed to support statistical applications. Similarities between the two types of systems are rarely discussed, mainly due to
differences in terminology and application domains.

4.2 Data Warehouse Modeling: Data Cube and OLAP

149

OLAP and SDB systems, however, have distinguishing differences. While SDBs tend
to focus on socioeconomic applications, OLAP has been targeted for business applications. Privacy issues regarding concept hierarchies are a major concern for SDBs. For
example, given summarized socioeconomic data, it is controversial to allow users to view
the corresponding low-level data. Finally, unlike SDBs, OLAP systems are designed for
efficiently handling huge amounts of data.

4.2.6 A Starnet Query Model for Querying
Multidimensional Databases
The querying of multidimensional databases can be based on a starnet model, which
consists of radial lines emanating from a central point, where each line represents a
concept hierarchy for a dimension. Each abstraction level in the hierarchy is called a
footprint. These represent the granularities available for use by OLAP operations such
as drill-down and roll-up.
Example 4.5 Starnet. A starnet query model for the AllElectronics data warehouse is shown in
Figure 4.13. This starnet consists of four radial lines, representing concept hierarchies
for the dimensions location, customer, item, and time, respectively. Each line consists
of footprints representing abstraction levels of the dimension. For example, the time
line has four footprints: “day,” “month,” “quarter,” and “year.” A concept hierarchy may
involve a single attribute (e.g., date for the time hierarchy) or several attributes (e.g., the
concept hierarchy for location involves the attributes street, city, province or state, and
country). In order to examine the item sales at AllElectronics, users can roll up along the
location

customer

continent

group

country
category

province_or_state
city

name

street
day

name

month
quarter
year
time

Figure 4.13 A starnet model of business queries.

brand

category

type

item

150

Chapter 4 Data Warehousing and Online Analytical Processing

time dimension from month to quarter, or, say, drill down along the location dimension
from country to city.
Concept hierarchies can be used to generalize data by replacing low-level values
(such as “day” for the time dimension) by higher-level abstractions (such as “year”),
or to specialize data by replacing higher-level abstractions with lower-level values.

4.3

Data Warehouse Design and Usage
“What goes into a data warehouse design? How are data warehouses used? How do data
warehousing and OLAP relate to data mining?” This section tackles these questions. We
study the design and usage of data warehousing for information processing, analytical processing, and data mining. We begin by presenting a business analysis framework
for data warehouse design (Section 4.3.1). Section 4.3.2 looks at the design process,
while Section 4.3.3 studies data warehouse usage. Finally, Section 4.3.4 describes multidimensional data mining, a powerful paradigm that integrates OLAP with data mining
technology.

4.3.1 A Business Analysis Framework for Data
Warehouse Design
“What can business analysts gain from having a data warehouse?” First, having a data
warehouse may provide a competitive advantage by presenting relevant information
from which to measure performance and make critical adjustments to help win over
competitors. Second, a data warehouse can enhance business productivity because it is
able to quickly and efficiently gather information that accurately describes the organization. Third, a data warehouse facilitates customer relationship management because it
provides a consistent view of customers and items across all lines of business, all departments, and all markets. Finally, a data warehouse may bring about cost reduction by
tracking trends, patterns, and exceptions over long periods in a consistent and reliable
manner.
To design an effective data warehouse we need to understand and analyze business needs and construct a business analysis framework. The construction of a large
and complex information system can be viewed as the construction of a large and
complex building, for which the owner, architect, and builder have different views.
These views are combined to form a complex framework that represents the top-down,
business-driven, or owner’s perspective, as well as the bottom-up, builder-driven, or
implementor’s view of the information system.
Four different views regarding a data warehouse design must be considered: the topdown view, the data source view, the data warehouse view, and the business query view.

4.3 Data Warehouse Design and Usage

151

The top-down view allows the selection of the relevant information necessary for the
data warehouse. This information matches current and future business needs.
The data source view exposes the information being captured, stored, and managed by operational systems. This information may be documented at various levels
of detail and accuracy, from individual data source tables to integrated data source
tables. Data sources are often modeled by traditional data modeling techniques, such
as the entity-relationship model or CASE (computer-aided software engineering)
tools.
The data warehouse view includes fact tables and dimension tables. It represents the
information that is stored inside the data warehouse, including precalculated totals
and counts, as well as information regarding the source, date, and time of origin,
added to provide historical context.
Finally, the business query view is the data perspective in the data warehouse from
the end-user’s viewpoint.
Building and using a data warehouse is a complex task because it requires business
skills, technology skills, and program management skills. Regarding business skills, building
a data warehouse involves understanding how systems store and manage their data, how
to build extractors that transfer data from the operational system to the data warehouse,
and how to build warehouse refresh software that keeps the data warehouse reasonably
up-to-date with the operational system’s data. Using a data warehouse involves understanding the significance of the data it contains, as well as understanding and translating
the business requirements into queries that can be satisfied by the data warehouse.
Regarding technology skills, data analysts are required to understand how to make
assessments from quantitative information and derive facts based on conclusions from
historic information in the data warehouse. These skills include the ability to discover
patterns and trends, to extrapolate trends based on history and look for anomalies or
paradigm shifts, and to present coherent managerial recommendations based on such
analysis. Finally, program management skills involve the need to interface with many
technologies, vendors, and end-users in order to deliver results in a timely and costeffective manner.

4.3.2 Data Warehouse Design Process
Let’s look at various approaches to the data warehouse design process and the steps
involved.
A data warehouse can be built using a top-down approach, a bottom-up approach,
or a combination of both. The top-down approach starts with overall design and planning. It is useful in cases where the technology is mature and well known, and where
the business problems that must be solved are clear and well understood. The bottomup approach starts with experiments and prototypes. This is useful in the early stage
of business modeling and technology development. It allows an organization to move

152

Chapter 4 Data Warehousing and Online Analytical Processing

forward at considerably less expense and to evaluate the technological benefits before
making significant commitments. In the combined approach, an organization can
exploit the planned and strategic nature of the top-down approach while retaining the
rapid implementation and opportunistic application of the bottom-up approach.
From the software engineering point of view, the design and construction of a data
warehouse may consist of the following steps: planning, requirements study, problem
analysis, warehouse design, data integration and testing, and finally deployment of the
data warehouse. Large software systems can be developed using one of two methodologies: the waterfall method or the spiral method. The waterfall method performs a
structured and systematic analysis at each step before proceeding to the next, which
is like a waterfall, falling from one step to the next. The spiral method involves the rapid
generation of increasingly functional systems, with short intervals between successive
releases. This is considered a good choice for data warehouse development, especially
for data marts, because the turnaround time is short, modifications can be done quickly,
and new designs and technologies can be adapted in a timely manner.
In general, the warehouse design process consists of the following steps:
1. Choose a business process to model (e.g., orders, invoices, shipments, inventory,
account administration, sales, or the general ledger). If the business process is organizational and involves multiple complex object collections, a data warehouse model
should be followed. However, if the process is departmental and focuses on the
analysis of one kind of business process, a data mart model should be chosen.
2. Choose the business process grain, which is the fundamental, atomic level of data
to be represented in the fact table for this process (e.g., individual transactions,
individual daily snapshots, and so on).
3. Choose the dimensions that will apply to each fact table record. Typical dimensions
are time, item, customer, supplier, warehouse, transaction type, and status.
4. Choose the measures that will populate each fact table record. Typical measures are
numeric additive quantities like dollars sold and units sold.
Because data warehouse construction is a difficult and long-term task, its implementation scope should be clearly defined. The goals of an initial data warehouse
implementation should be specific, achievable, and measurable. This involves determining the time and budget allocations, the subset of the organization that is to be modeled,
the number of data sources selected, and the number and types of departments to be
served.
Once a data warehouse is designed and constructed, the initial deployment of
the warehouse includes initial installation, roll-out planning, training, and orientation. Platform upgrades and maintenance must also be considered. Data warehouse
administration includes data refreshment, data source synchronization, planning for
disaster recovery, managing access control and security, managing data growth, managing database performance, and data warehouse enhancement and extension. Scope

4.3 Data Warehouse Design and Usage

153

management includes controlling the number and range of queries, dimensions, and
reports; limiting the data warehouse’s size; or limiting the schedule, budget, or resources.
Various kinds of data warehouse design tools are available. Data warehouse
development tools provide functions to define and edit metadata repository contents
(e.g., schemas, scripts, or rules), answer queries, output reports, and ship metadata to
and from relational database system catalogs. Planning and analysis tools study the
impact of schema changes and of refresh performance when changing refresh rates or
time windows.

4.3.3 Data Warehouse Usage for Information Processing
Data warehouses and data marts are used in a wide range of applications. Business
executives use the data in data warehouses and data marts to perform data analysis
and make strategic decisions. In many firms, data warehouses are used as an integral
part of a plan-execute-assess “closed-loop” feedback system for enterprise management.
Data warehouses are used extensively in banking and financial services, consumer goods
and retail distribution sectors, and controlled manufacturing such as demand-based
production.
Typically, the longer a data warehouse has been in use, the more it will have evolved.
This evolution takes place throughout a number of phases. Initially, the data warehouse
is mainly used for generating reports and answering predefined queries. Progressively, it
is used to analyze summarized and detailed data, where the results are presented in the
form of reports and charts. Later, the data warehouse is used for strategic purposes, performing multidimensional analysis and sophisticated slice-and-dice operations. Finally,
the data warehouse may be employed for knowledge discovery and strategic decision
making using data mining tools. In this context, the tools for data warehousing can be
categorized into access and retrieval tools, database reporting tools, data analysis tools, and
data mining tools.
Business users need to have the means to know what exists in the data warehouse
(through metadata), how to access the contents of the data warehouse, how to examine
the contents using analysis tools, and how to present the results of such analysis.
There are three kinds of data warehouse applications: information processing, analytical processing, and data mining.
Information processing supports querying, basic statistical analysis, and reporting
using crosstabs, tables, charts, or graphs. A current trend in data warehouse information processing is to construct low-cost web-based accessing tools that are then
integrated with web browsers.
Analytical processing supports basic OLAP operations, including slice-and-dice,
drill-down, roll-up, and pivoting. It generally operates on historic data in both summarized and detailed forms. The major strength of online analytical processing over
information processing is the multidimensional data analysis of data warehouse data.

154

Chapter 4 Data Warehousing and Online Analytical Processing

Data mining supports knowledge discovery by finding hidden patterns and associations, constructing analytical models, performing classification and prediction, and
presenting the mining results using visualization tools.
“How does data mining relate to information processing and online analytical processing?” Information processing, based on queries, can find useful information. However,
answers to such queries reflect the information directly stored in databases or computable by aggregate functions. They do not reflect sophisticated patterns or regularities
buried in the database. Therefore, information processing is not data mining.
Online analytical processing comes a step closer to data mining because it can derive
information summarized at multiple granularities from user-specified subsets of a data
warehouse. Such descriptions are equivalent to the class/concept descriptions discussed
in Chapter 1. Because data mining systems can also mine generalized class/concept
descriptions, this raises some interesting questions: “Do OLAP systems perform data
mining? Are OLAP systems actually data mining systems?”
The functionalities of OLAP and data mining can be viewed as disjoint: OLAP is a
data summarization/aggregation tool that helps simplify data analysis, while data mining
allows the automated discovery of implicit patterns and interesting knowledge hidden
in large amounts of data. OLAP tools are targeted toward simplifying and supporting
interactive data analysis, whereas the goal of data mining tools is to automate as much
of the process as possible, while still allowing users to guide the process. In this sense,
data mining goes one step beyond traditional online analytical processing.
An alternative and broader view of data mining may be adopted in which data mining
covers both data description and data modeling. Because OLAP systems can present
general descriptions of data from data warehouses, OLAP functions are essentially for
user-directed data summarization and comparison (by drilling, pivoting, slicing, dicing, and other operations). These are, though limited, data mining functionalities. Yet
according to this view, data mining covers a much broader spectrum than simple OLAP
operations, because it performs not only data summarization and comparison but also
association, classification, prediction, clustering, time-series analysis, and other data
analysis tasks.
Data mining is not confined to the analysis of data stored in data warehouses. It may
analyze data existing at more detailed granularities than the summarized data provided
in a data warehouse. It may also analyze transactional, spatial, textual, and multimedia
data that are difficult to model with current multidimensional database technology. In
this context, data mining covers a broader spectrum than OLAP with respect to data
mining functionality and the complexity of the data handled.
Because data mining involves more automated and deeper analysis than OLAP, it
is expected to have broader applications. Data mining can help business managers find
and reach more suitable customers, as well as gain critical business insights that may help
drive market share and raise profits. In addition, data mining can help managers understand customer group characteristics and develop optimal pricing strategies accordingly.
It can correct item bundling based not on intuition but on actual item groups derived
from customer purchase patterns, reduce promotional spending, and at the same time
increase the overall net effectiveness of promotions.

4.3 Data Warehouse Design and Usage

155

4.3.4 From Online Analytical Processing
to Multidimensional Data Mining
The data mining field has conducted substantial research regarding mining on various data types, including relational data, data from data warehouses, transaction data,
time-series data, spatial data, text data, and flat files. Multidimensional data mining
(also known as exploratory multidimensional data mining, online analytical mining,
or OLAM) integrates OLAP with data mining to uncover knowledge in multidimensional databases. Among the many different paradigms and architectures of data mining
systems, multidimensional data mining is particularly important for the following
reasons:
High quality of data in data warehouses: Most data mining tools need to work on
integrated, consistent, and cleaned data, which requires costly data cleaning, data
integration, and data transformation as preprocessing steps. A data warehouse constructed by such preprocessing serves as a valuable source of high-quality data for
OLAP as well as for data mining. Notice that data mining may serve as a valuable
tool for data cleaning and data integration as well.
Available information processing infrastructure surrounding data warehouses:
Comprehensive information processing and data analysis infrastructures have been
or will be systematically constructed surrounding data warehouses, which include
accessing, integration, consolidation, and transformation of multiple heterogeneous
databases, ODBC/OLEDB connections, Web accessing and service facilities, and
reporting and OLAP analysis tools. It is prudent to make the best use of the available
infrastructures rather than constructing everything from scratch.
OLAP-based exploration of multidimensional data: Effective data mining needs
exploratory data analysis. A user will often want to traverse through a database, select
portions of relevant data, analyze them at different granularities, and present knowledge/results in different forms. Multidimensional data mining provides facilities for
mining on different subsets of data and at varying levels of abstraction—by drilling,
pivoting, filtering, dicing, and slicing on a data cube and/or intermediate data mining results. This, together with data/knowledge visualization tools, greatly enhances
the power and flexibility of data mining.
Online selection of data mining functions: Users may not always know the specific
kinds of knowledge they want to mine. By integrating OLAP with various data mining functions, multidimensional data mining provides users with the flexibility to
select desired data mining functions and swap data mining tasks dynamically.
Chapter 5 describes data warehouses on a finer level by exploring implementation
issues such as data cube computation, OLAP query answering strategies, and multidimensional data mining. The chapters following it are devoted to the study of data
mining techniques. As we have seen, the introduction to data warehousing and OLAP
technology presented in this chapter is essential to our study of data mining. This
is because data warehousing provides users with large amounts of clean, organized,

156

Chapter 4 Data Warehousing and Online Analytical Processing

and summarized data, which greatly facilitates data mining. For example, rather than
storing the details of each sales transaction, a data warehouse may store a summary
of the transactions per item type for each branch or, summarized to a higher level,
for each country. The capability of OLAP to provide multiple and dynamic views
of summarized data in a data warehouse sets a solid foundation for successful data
mining.
Moreover, we also believe that data mining should be a human-centered process.
Rather than asking a data mining system to generate patterns and knowledge automatically, a user will often need to interact with the system to perform exploratory data
analysis. OLAP sets a good example for interactive data analysis and provides the necessary preparations for exploratory data mining. Consider the discovery of association
patterns, for example. Instead of mining associations at a primitive (i.e., low) data level
among transactions, users should be allowed to specify roll-up operations along any
dimension.
For example, a user may want to roll up on the item dimension to go from viewing the
data for particular TV sets that were purchased to viewing the brands of these TVs (e.g.,
SONY or Toshiba). Users may also navigate from the transaction level to the customer or
customer-type level in the search for interesting associations. Such an OLAP data mining
style is characteristic of multidimensional data mining. In our study of the principles
of data mining in this book, we place particular emphasis on multidimensional data
mining, that is, on the integration of data mining and OLAP technology.

4.4

Data Warehouse Implementation
Data warehouses contain huge volumes of data. OLAP servers demand that decision
support queries be answered in the order of seconds. Therefore, it is crucial for data
warehouse systems to support highly efficient cube computation techniques, access
methods, and query processing techniques. In this section, we present an overview
of methods for the efficient implementation of data warehouse systems. Section 4.4.1
explores how to compute data cubes efficiently. Section 4.4.2 shows how OLAP data
can be indexed, using either bitmap or join indices. Next, we study how OLAP queries
are processed (Section 4.4.3). Finally, Section 4.4.4 presents various types of warehouse
servers for OLAP processing.

4.4.1 Efficient Data Cube Computation: An Overview
At the core of multidimensional data analysis is the efficient computation of aggregations across many sets of dimensions. In SQL terms, these aggregations are referred to
as group-by’s. Each group-by can be represented by a cuboid, where the set of group-by’s
forms a lattice of cuboids defining a data cube. In this subsection, we explore issues
relating to the efficient computation of data cubes.

4.4 Data Warehouse Implementation

157

The compute cube Operator and the Curse
of Dimensionality
One approach to cube computation extends SQL so as to include a compute cube operator. The compute cube operator computes aggregates over all subsets of the dimensions
specified in the operation. This can require excessive storage space, especially for large
numbers of dimensions. We start with an intuitive look at what is involved in the
efficient computation of data cubes.
Example 4.6 A data cube is a lattice of cuboids. Suppose that you want to create a data cube for
AllElectronics sales that contains the following: city, item, year, and sales in dollars. You
want to be able to analyze the data, with queries such as the following:
“Compute the sum of sales, grouping by city and item.”
“Compute the sum of sales, grouping by city.”
“Compute the sum of sales, grouping by item.”
What is the total number of cuboids, or group-by’s, that can be computed for this
data cube? Taking the three attributes, city, item, and year, as the dimensions for the
data cube, and sales in dollars as the measure, the total number of cuboids, or groupby’s, that can be computed for this data cube is 23 = 8. The possible group-by’s are
the following: {(city, item, year), (city, item), (city, year), (item, year), (city), (item),
(year), ()}, where () means that the group-by is empty (i.e., the dimensions are not
grouped). These group-by’s form a lattice of cuboids for the data cube, as shown in
Figure 4.14.

O-D (apex) cuboid

()

(city)

(item)

(year)

1-D cuboids

2-D cuboids
(city, item)

(city, year)

(item, year)
3-D (base) cuboid

(city, item, year)

Figure 4.14 Lattice of cuboids, making up a 3-D data cube. Each cuboid represents a different group-by.
The base cuboid contains city, item, and year dimensions.

158

Chapter 4 Data Warehousing and Online Analytical Processing

The base cuboid contains all three dimensions, city, item, and year. It can return
the total sales for any combination of the three dimensions. The apex cuboid, or 0-D
cuboid, refers to the case where the group-by is empty. It contains the total sum of all
sales. The base cuboid is the least generalized (most specific) of the cuboids. The apex
cuboid is the most generalized (least specific) of the cuboids, and is often denoted as all.
If we start at the apex cuboid and explore downward in the lattice, this is equivalent to
drilling down within the data cube. If we start at the base cuboid and explore upward,
this is akin to rolling up.
An SQL query containing no group-by (e.g., “compute the sum of total sales”) is a zerodimensional operation. An SQL query containing one group-by (e.g., “compute the sum
of sales, group-by city”) is a one-dimensional operation. A cube operator on n dimensions
is equivalent to a collection of group-by statements, one for each subset of the n dimensions. Therefore, the cube operator is the n-dimensional generalization of the group-by
operator.
Similar to the SQL syntax, the data cube in Example 4.1 could be defined as
define cube sales cube [city, item, year]: sum(sales in dollars)

For a cube with n dimensions, there are a total of 2n cuboids, including the base cuboid.
A statement such as
compute cube sales cube

would explicitly instruct the system to compute the sales aggregate cuboids for all eight
subsets of the set {city, item, year}, including the empty subset. A cube computation
operator was first proposed and studied by Gray et al. [GCB+ 97].
Online analytical processing may need to access different cuboids for different
queries. Therefore, it may seem like a good idea to compute in advance all or at least
some of the cuboids in a data cube. Precomputation leads to fast response time and
avoids some redundant computation. Most, if not all, OLAP products resort to some
degree of precomputation of multidimensional aggregates.
A major challenge related to this precomputation, however, is that the required storage space may explode if all the cuboids in a data cube are precomputed, especially when
the cube has many dimensions. The storage requirements are even more excessive when
many of the dimensions have associated concept hierarchies, each with multiple levels.
This problem is referred to as the curse of dimensionality. The extent of the curse of
dimensionality is illustrated here.
“How many cuboids are there in an n-dimensional data cube?” If there were no
hierarchies associated with each dimension, then the total number of cuboids for an
n-dimensional data cube, as we have seen, is 2n . However, in practice, many dimensions
do have hierarchies. For example, time is usually explored not at only one conceptual
level (e.g., year), but rather at multiple conceptual levels such as in the hierarchy “day <
month < quarter < year.” For an n-dimensional data cube, the total number of cuboids

4.4 Data Warehouse Implementation

159

that can be generated (including the cuboids generated by climbing up the hierarchies
along each dimension) is
Total number of cuboids =

n
Y
(Li + 1),

(4.1)

i=1

where Li is the number of levels associated with dimension i. One is added to Li in
Eq. (4.1) to include the virtual top level, all. (Note that generalizing to all is equivalent to
the removal of the dimension.)
This formula is based on the fact that, at most, one abstraction level in each dimension will appear in a cuboid. For example, the time dimension as specified before has
four conceptual levels, or five if we include the virtual level all. If the cube has 10 dimensions and each dimension has five levels (including all), the total number of cuboids
that can be generated is 510 ≈ 9.8 × 106 . The size of each cuboid also depends on the
cardinality (i.e., number of distinct values) of each dimension. For example, if the AllElectronics branch in each city sold every item, there would be |city| × |item| tuples in the
city− item group-by alone. As the number of dimensions, number of conceptual hierarchies, or cardinality increases, the storage space required for many of the group-by’s will
grossly exceed the (fixed) size of the input relation.
By now, you probably realize that it is unrealistic to precompute and materialize all
of the cuboids that can possibly be generated for a data cube (i.e., from a base cuboid).
If there are many cuboids, and these cuboids are large in size, a more reasonable option
is partial materialization; that is, to materialize only some of the possible cuboids that
can be generated.

Partial Materialization: Selected Computation
of Cuboids
There are three choices for data cube materialization given a base cuboid:
1. No materialization: Do not precompute any of the “nonbase” cuboids. This leads
to computing expensive multidimensional aggregates on-the-fly, which can be extremely slow.
2. Full materialization: Precompute all of the cuboids. The resulting lattice of computed cuboids is referred to as the full cube. This choice typically requires huge
amounts of memory space in order to store all of the precomputed cuboids.
3. Partial materialization: Selectively compute a proper subset of the whole set of possible cuboids. Alternatively, we may compute a subset of the cube, which contains
only those cells that satisfy some user-specified criterion, such as where the tuple
count of each cell is above some threshold. We will use the term subcube to refer to
the latter case, where only some of the cells may be precomputed for various cuboids.
Partial materialization represents an interesting trade-off between storage space and
response time.

160

Chapter 4 Data Warehousing and Online Analytical Processing

The partial materialization of cuboids or subcubes should consider three factors: (1)
identify the subset of cuboids or subcubes to materialize; (2) exploit the materialized
cuboids or subcubes during query processing; and (3) efficiently update the materialized
cuboids or subcubes during load and refresh.
The selection of the subset of cuboids or subcubes to materialize should take into
account the queries in the workload, their frequencies, and their accessing costs. In addition, it should consider workload characteristics, the cost for incremental updates, and
the total storage requirements. The selection must also consider the broad context of
physical database design such as the generation and selection of indices. Several OLAP
products have adopted heuristic approaches for cuboid and subcube selection. A popular approach is to materialize the cuboids set on which other frequently referenced
cuboids are based. Alternatively, we can compute an iceberg cube, which is a data cube
that stores only those cube cells with an aggregate value (e.g., count) that is above some
minimum support threshold.
Another common strategy is to materialize a shell cube. This involves precomputing the cuboids for only a small number of dimensions (e.g., three to five) of a data
cube. Queries on additional combinations of the dimensions can be computed on-thefly. Because our aim in this chapter is to provide a solid introduction and overview of
data warehousing for data mining, we defer our detailed discussion of cuboid selection
and computation to Chapter 5, which studies various data cube computation methods
in greater depth.
Once the selected cuboids have been materialized, it is important to take advantage of
them during query processing. This involves several issues, such as how to determine the
relevant cuboid(s) from among the candidate materialized cuboids, how to use available
index structures on the materialized cuboids, and how to transform the OLAP operations onto the selected cuboid(s). These issues are discussed in Section 4.4.3 as well as in
Chapter 5.
Finally, during load and refresh, the materialized cuboids should be updated efficiently. Parallelism and incremental update techniques for this operation should be
explored.

4.4.2 Indexing OLAP Data: Bitmap Index and Join Index
To facilitate efficient data accessing, most data warehouse systems support index structures and materialized views (using cuboids). General methods to select cuboids for
materialization were discussed in Section 4.4.1. In this subsection, we examine how to
index OLAP data by bitmap indexing and join indexing.
The bitmap indexing method is popular in OLAP products because it allows quick
searching in data cubes. The bitmap index is an alternative representation of the
record ID (RID) list. In the bitmap index for a given attribute, there is a distinct bit
vector, Bv, for each value v in the attribute’s domain. If a given attribute’s domain consists of n values, then n bits are needed for each entry in the bitmap index (i.e., there are
n bit vectors). If the attribute has the value v for a given row in the data table, then the
bit representing that value is set to 1 in the corresponding row of the bitmap index. All
other bits for that row are set to 0.

4.4 Data Warehouse Implementation

161

Example 4.7 Bitmap indexing. In the AllElectronics data warehouse, suppose the dimension item at
the top level has four values (representing item types): “home entertainment,” “computer,” “phone,” and “security.” Each value (e.g., “computer”) is represented by a bit vector
in the item bitmap index table. Suppose that the cube is stored as a relation table with
100,000 rows. Because the domain of item consists of four values, the bitmap index table
requires four bit vectors (or lists), each with 100,000 bits. Figure 4.15 shows a base (data)
table containing the dimensions item and city, and its mapping to bitmap index tables
for each of the dimensions.
item bitmap index table

Base table

city bitmap index table

RID

item

city

RID

H

C

P

S

RID

V

T

R1
R2
R3
R4
R5
R6
R7
R8

H
C
P
S
H
C
P
S

V
V
V
V
T
T
T
T

R1
R2
R3
R4
R5
R6
R7
R8

1
0
0
0
1
0
0
0

0
1
0
0
0
1
0
0

0
0
1
0
0
0
1
0

0
0
0
1
0
0
0
1

R1
R2
R3
R4
R5
R6
R7
R8

1
1
1
1
0
0
0
0

0
0
0
0
1
1
1
1

Note: H for “home entertainment,” C for “computer,” P for “phone,” S for “security,”
V for “Vancouver,” T for “Toronto.”

Figure 4.15 Indexing OLAP data using bitmap indices.

Bitmap indexing is advantageous compared to hash and tree indices. It is especially
useful for low-cardinality domains because comparison, join, and aggregation operations are then reduced to bit arithmetic, which substantially reduces the processing time.
Bitmap indexing leads to significant reductions in space and input/output (I/O) since a
string of characters can be represented by a single bit. For higher-cardinality domains,
the method can be adapted using compression techniques.
The join indexing method gained popularity from its use in relational database query
processing. Traditional indexing maps the value in a given column to a list of rows having
that value. In contrast, join indexing registers the joinable rows of two relations from a
relational database. For example, if two relations R(RID, A) and S(B, SID) join on the
attributes A and B, then the join index record contains the pair (RID, SID), where RID
and SID are record identifiers from the R and S relations, respectively. Hence, the join
index records can identify joinable tuples without performing costly join operations.
Join indexing is especially useful for maintaining the relationship between a foreign key2
and its matching primary keys, from the joinable relation.
The star schema model of data warehouses makes join indexing attractive for crosstable search, because the linkage between a fact table and its corresponding dimension
tables comprises the fact table’s foreign key and the dimension table’s primary key. Join
2A

set of attributes in a relation schema that forms a primary key for another relation schema is called
a foreign key.

162

Chapter 4 Data Warehousing and Online Analytical Processing

indexing maintains relationships between attribute values of a dimension (e.g., within
a dimension table) and the corresponding rows in the fact table. Join indices may span
multiple dimensions to form composite join indices. We can use join indices to identify
subcubes that are of interest.
Example 4.8 Join indexing. In Example 3.4, we defined a star schema for AllElectronics of the form
“sales star [time, item, branch, location]: dollars sold = sum (sales in dollars).” An example of a join index relationship between the sales fact table and the location and item
dimension tables is shown in Figure 4.16. For example, the “Main Street” value in the
location dimension table joins with tuples T57, T238, and T884 of the sales fact table.
Similarly, the “Sony-TV” value in the item dimension table joins with tuples T57 and
T459 of the sales fact table. The corresponding join index tables are shown in Figure 4.17.
sales
location

item
T57

Main Street

Sony-TV
T238
T459
T884

Figure 4.16 Linkages between a sales fact table and location and item dimension tables.
Join index table for
location/sales
location
sales_key
Main Street
Main Street
Main Street

T57
T238
T884

Join index table for
item/sales
item
sales_key
Sony-TV
Sony-TV

T57
T459

Join index table linking
location and item to sales
location
Main Street

item
Sony-TV

sales_key
T57

Figure 4.17 Join index tables based on the linkages between the sales fact table and the location and item
dimension tables shown in Figure 4.16.

4.4 Data Warehouse Implementation

163

Suppose that there are 360 time values, 100 items, 50 branches, 30 locations, and 10
million sales tuples in the sales star data cube. If the sales fact table has recorded sales
for only 30 items, the remaining 70 items will obviously not participate in joins. If join
indices are not used, additional I/Os have to be performed to bring the joining portions
of the fact table and the dimension tables together.
To further speed up query processing, the join indexing and the bitmap indexing
methods can be integrated to form bitmapped join indices.

4.4.3 Efficient Processing of OLAP Queries
The purpose of materializing cuboids and constructing OLAP index structures is to
speed up query processing in data cubes. Given materialized views, query processing
should proceed as follows:
1. Determine which operations should be performed on the available cuboids: This
involves transforming any selection, projection, roll-up (group-by), and drill-down
operations specified in the query into corresponding SQL and/or OLAP operations.
For example, slicing and dicing a data cube may correspond to selection and/or
projection operations on a materialized cuboid.
2. Determine to which materialized cuboid(s) the relevant operations should be
applied: This involves identifying all of the materialized cuboids that may potentially be used to answer the query, pruning the set using knowledge of “dominance” relationships among the cuboids, estimating the costs of using the remaining
materialized cuboids, and selecting the cuboid with the least cost.
Example 4.9 OLAP query processing. Suppose that we define a data cube for AllElectronics of the
form “sales cube [time, item, location]: sum(sales in dollars).” The dimension hierarchies
used are “day < month < quarter < year” for time; “item name < brand < type” for
item; and “street < city < province or state < country” for location.
Suppose that the query to be processed is on {brand, province or state}, with the
selection constant “year = 2010.” Also, suppose that there are four materialized cuboids
available, as follows:
cuboid 1: {year, item name, city}
cuboid 2: {year, brand, country}
cuboid 3: {year, brand, province or state}
cuboid 4: {item name, province or state}, where year = 2010
“Which of these four cuboids should be selected to process the query?” Finer-granularity
data cannot be generated from coarser-granularity data. Therefore, cuboid 2 cannot be
used because country is a more general concept than province or state. Cuboids 1, 3, and
4 can be used to process the query because (1) they have the same set or a superset of the

164

Chapter 4 Data Warehousing and Online Analytical Processing

dimensions in the query, (2) the selection clause in the query can imply the selection in
the cuboid, and (3) the abstraction levels for the item and location dimensions in these
cuboids are at a finer level than brand and province or state, respectively.
“How would the costs of each cuboid compare if used to process the query?” It is likely
that using cuboid 1 would cost the most because both item name and city are at a lower
level than the brand and province or state concepts specified in the query. If there are
not many year values associated with items in the cube, but there are several item names
for each brand, then cuboid 3 will be smaller than cuboid 4, and thus cuboid 3 should
be chosen to process the query. However, if efficient indices are available for cuboid 4,
then cuboid 4 may be a better choice. Therefore, some cost-based estimation is required
to decide which set of cuboids should be selected for query processing.

4.4.4 OLAP Server Architectures: ROLAP versus MOLAP
versus HOLAP
Logically, OLAP servers present business users with multidimensional data from data
warehouses or data marts, without concerns regarding how or where the data are stored.
However, the physical architecture and implementation of OLAP servers must consider
data storage issues. Implementations of a warehouse server for OLAP processing include
the following:
Relational OLAP (ROLAP) servers: These are the intermediate servers that stand in
between a relational back-end server and client front-end tools. They use a relational or extended-relational DBMS to store and manage warehouse data, and OLAP
middleware to support missing pieces. ROLAP servers include optimization for
each DBMS back end, implementation of aggregation navigation logic, and additional tools and services. ROLAP technology tends to have greater scalability than
MOLAP technology. The DSS server of Microstrategy, for example, adopts the
ROLAP approach.
Multidimensional OLAP (MOLAP) servers: These servers support multidimensional
data views through array-based multidimensional storage engines. They map multidimensional views directly to data cube array structures. The advantage of using a
data cube is that it allows fast indexing to precomputed summarized data. Notice
that with multidimensional data stores, the storage utilization may be low if the data
set is sparse. In such cases, sparse matrix compression techniques should be explored
(Chapter 5).
Many MOLAP servers adopt a two-level storage representation to handle dense
and sparse data sets: Denser subcubes are identified and stored as array structures, whereas sparse subcubes employ compression technology for efficient storage
utilization.
Hybrid OLAP (HOLAP) servers: The hybrid OLAP approach combines ROLAP and
MOLAP technology, benefiting from the greater scalability of ROLAP and the faster
computation of MOLAP. For example, a HOLAP server may allow large volumes

4.5 Data Warehouse Implementation

165

of detailed data to be stored in a relational database, while aggregations are kept in
a separate MOLAP store. The Microsoft SQL Server 2000 supports a hybrid OLAP
server.
Specialized SQL servers: To meet the growing demand of OLAP processing in relational databases, some database system vendors implement specialized SQL servers
that provide advanced query language and query processing support for SQL queries
over star and snowflake schemas in a read-only environment.
“How are data actually stored in ROLAP and MOLAP architectures?” Let’s first look
at ROLAP. As its name implies, ROLAP uses relational tables to store data for online
analytical processing. Recall that the fact table associated with a base cuboid is referred
to as a base fact table. The base fact table stores data at the abstraction level indicated
by the join keys in the schema for the given data cube. Aggregated data can also be
stored in fact tables, referred to as summary fact tables. Some summary fact tables store
both base fact table data and aggregated data (see Example 3.10). Alternatively, separate
summary fact tables can be used for each abstraction level to store only aggregated data.
Example 4.10 A ROLAP data store. Table 4.4 shows a summary fact table that contains both base fact
data and aggregated data. The schema is “hrecord identifier (RID), item, . . . , day, month,
quarter, year, dollars soldi,” where day, month, quarter, and year define the sales date,
and dollars sold is the sales amount. Consider the tuples with an RID of 1001 and 1002,
respectively. The data of these tuples are at the base fact level, where the sales dates are
October 15, 2010, and October 23, 2010, respectively. Consider the tuple with an RID
of 5001. This tuple is at a more general level of abstraction than the tuples 1001 and
1002. The day value has been generalized to all, so that the corresponding time value is
October 2010. That is, the dollars sold amount shown is an aggregation representing the
entire month of October 2010, rather than just October 15 or 23, 2010. The special value
all is used to represent subtotals in summarized data.
MOLAP uses multidimensional array structures to store data for online analytical
processing. This structure is discussed in greater detail in Chapter 5.
Most data warehouse systems adopt a client-server architecture. A relational data
store always resides at the data warehouse/data mart server site. A multidimensional
data store can reside at either the database server site or the client site.
Table 4.4 Single Table for Base and Summary Facts
RID

item

...

day

month

quarter

year

dollars sold

1001
1002
...
5001
...

TV
TV
...
TV
...

...
...
...
...
...

15
23
...
all
...

10
10
...
10
...

Q4
Q4
...
Q4
...

2010
2010
...
2010
...

250.60
175.00
...
45,786.08
...

166

Chapter 4 Data Warehousing and Online Analytical Processing

4.5

Data Generalization by Attribute-Oriented
Induction
Conceptually, the data cube can be viewed as a kind of multidimensional data generalization. In general, data generalization summarizes data by replacing relatively low-level
values (e.g., numeric values for an attribute age) with higher-level concepts (e.g., young,
middle-aged, and senior), or by reducing the number of dimensions to summarize data
in concept space involving fewer dimensions (e.g., removing birth date and telephone
number when summarizing the behavior of a group of students). Given the large amount
of data stored in databases, it is useful to be able to describe concepts in concise and succinct terms at generalized (rather than low) levels of abstraction. Allowing data sets to
be generalized at multiple levels of abstraction facilitates users in examining the general behavior of the data. Given the AllElectronics database, for example, instead of
examining individual customer transactions, sales managers may prefer to view the
data generalized to higher levels, such as summarized by customer groups according
to geographic regions, frequency of purchases per group, and customer income.
This leads us to the notion of concept description, which is a form of data generalization. A concept typically refers to a data collection such as frequent buyers, graduate students, and so on. As a data mining task, concept description is not a simple
enumeration of the data. Instead, concept description generates descriptions for data
characterization and comparison. It is sometimes called class description when the concept to be described refers to a class of objects. Characterization provides a concise and
succinct summarization of the given data collection, while concept or class comparison (also known as discrimination) provides descriptions comparing two or more data
collections.
Up to this point, we have studied data cube (or OLAP) approaches to concept
description using multidimensional, multilevel data generalization in data warehouses.
“Is data cube technology sufficient to accomplish all kinds of concept description tasks for
large data sets?” Consider the following cases.
Complex data types and aggregation: Data warehouses and OLAP tools are based
on a multidimensional data model that views data in the form of a data cube, consisting of dimensions (or attributes) and measures (aggregate functions). However,
many current OLAP systems confine dimensions to non-numeric data and measures
to numeric data. In reality, the database can include attributes of various data types,
including numeric, non-numeric, spatial, text, or image, which ideally should be
included in the concept description.
Furthermore, the aggregation of attributes in a database may include sophisticated
data types such as the collection of non-numeric data, the merging of spatial regions,
the composition of images, the integration of texts, and the grouping of object pointers. Therefore, OLAP, with its restrictions on the possible dimension and measure
types, represents a simplified model for data analysis. Concept description should
handle complex data types of the attributes and their aggregations, as necessary.

4.5 Data Generalization by Attribute-Oriented Induction

167

User control versus automation: Online analytical processing in data warehouses
is a user-controlled process. The selection of dimensions and the application of
OLAP operations (e.g., drill-down, roll-up, slicing, and dicing) are primarily directed
and controlled by users. Although the control in most OLAP systems is quite userfriendly, users do require a good understanding of the role of each dimension.
Furthermore, in order to find a satisfactory description of the data, users may need to
specify a long sequence of OLAP operations. It is often desirable to have a more automated process that helps users determine which dimensions (or attributes) should
be included in the analysis, and the degree to which the given data set should be
generalized in order to produce an interesting summarization of the data.
This section presents an alternative method for concept description, called attributeoriented induction, which works for complex data types and relies on a data-driven
generalization process.

4.5.1 Attribute-Oriented Induction for Data Characterization
The attribute-oriented induction (AOI) approach to concept description was first proposed in 1989, a few years before the introduction of the data cube approach. The data
cube approach is essentially based on materialized views of the data, which typically
have been precomputed in a data warehouse. In general, it performs offline aggregation before an OLAP or data mining query is submitted for processing. On the
other hand, the attribute-oriented induction approach is basically a query-oriented,
generalization-based, online data analysis technique. Note that there is no inherent
barrier distinguishing the two approaches based on online aggregation versus offline
precomputation. Some aggregations in the data cube can be computed online, while
offline precomputation of multidimensional space can speed up attribute-oriented
induction as well.
The general idea of attribute-oriented induction is to first collect the task-relevant
data using a database query and then perform generalization based on the examination
of the number of each attribute’s distinct values in the relevant data set. The generalization is performed by either attribute removal or attribute generalization. Aggregation
is performed by merging identical generalized tuples and accumulating their respective counts. This reduces the size of the generalized data set. The resulting generalized
relation can be mapped into different forms (e.g., charts or rules) for presentation to
the user.
The following illustrates the process of attribute-oriented induction. We first discuss
its use for characterization. The method is extended for the mining of class comparisons
in Section 4.5.3.
Example 4.11 A data mining query for characterization. Suppose that a user wants to describe
the general characteristics of graduate students in the Big University database, given
the attributes name, gender, major, birth place, birth date, residence, phone# (telephone

168

Chapter 4 Data Warehousing and Online Analytical Processing

number), and gpa (grade point average). A data mining query for this characterization
can be expressed in the data mining query language, DMQL, as follows:
use Big University DB
mine characteristics as “Science Students”
in relevance to name, gender, major, birth place, birth date, residence,

phone#, gpa
from student
where status in “graduate”

We will see how this example of a typical data mining query can apply attribute-oriented
induction to the mining of characteristic descriptions.
First, data focusing should be performed before attribute-oriented induction. This
step corresponds to the specification of the task-relevant data (i.e., data for analysis). The
data are collected based on the information provided in the data mining query. Because
a data mining query is usually relevant to only a portion of the database, selecting the
relevant data set not only makes mining more efficient, but also derives more meaningful
results than mining the entire database.
Specifying the set of relevant attributes (i.e., attributes for mining, as indicated in
DMQL with the in relevance to clause) may be difficult for the user. A user may select
only a few attributes that he or she feels are important, while missing others that could
also play a role in the description. For example, suppose that the dimension birth place
is defined by the attributes city, province or state, and country. Of these attributes, let’s
say that the user has only thought to specify city. In order to allow generalization on
the birth place dimension, the other attributes defining this dimension should also be
included. In other words, having the system automatically include province or state and
country as relevant attributes allows city to be generalized to these higher conceptual
levels during the induction process.
At the other extreme, suppose that the user may have introduced too many attributes
by specifying all of the possible attributes with the clause in relevance to ∗. In this case,
all of the attributes in the relation specified by the from clause would be included in the
analysis. Many of these attributes are unlikely to contribute to an interesting description.
A correlation-based analysis method (Section 3.3.2) can be used to perform attribute
relevance analysis and filter out statistically irrelevant or weakly relevant attributes from
the descriptive mining process. Other approaches such as attribute subset selection, are
also described in Chapter 3.
Table 4.5 Initial Working Relation: A Collection of Task-Relevant Data
name

gender major

birth place

birth date residence

phone#

gpa

Jim Woodman
Scott Lachance
Laura Lee
···

M
M
F
···

Vancouver, BC, Canada
Montreal, Que, Canada
Seattle, WA, USA
···

12-8-76
7-28-75
8-25-70
···

687-4598
253-9106
420-5232
···

3.67
3.70
3.83
···

CS
CS
Physics
···

3511 Main St., Richmond
345 1st Ave., Richmond
125 Austin Ave., Burnaby
···

4.5 Data Generalization by Attribute-Oriented Induction

169

“What does the ‘where status in “graduate”’ clause mean?” The where clause implies
that a concept hierarchy exists for the attribute status. Such a concept hierarchy organizes
primitive-level data values for status (e.g., “M.Sc.,” “M.A.,” “M.B.A.,” “Ph.D.,” “B.Sc.,”
and “B.A.”) into higher conceptual levels (e.g., “graduate” and “undergraduate”). This
use of concept hierarchies does not appear in traditional relational query languages, yet
is likely to become a common feature in data mining query languages.
The data mining query presented in Example 4.11 is transformed into the following
relational query for the collection of the task-relevant data set:
use Big University DB
select name, gender, major, birth place, birth date, residence, phone#, gpa
from student
where status in {“M.Sc.,” “M.A.,” “M.B.A.,” “Ph.D.”}

The transformed query is executed against the relational database, Big University DB,
and returns the data shown earlier in Table 4.5. This table is called the (task-relevant)
initial working relation. It is the data on which induction will be performed. Note that
each tuple is, in fact, a conjunction of attribute–value pairs. Hence, we can think of a
tuple within a relation as a rule of conjuncts, and of induction on the relation as the
generalization of these rules.
“Now that the data are ready for attribute-oriented induction, how is attribute-oriented
induction performed?” The essential operation of attribute-oriented induction is data
generalization, which can be performed in either of two ways on the initial working
relation: attribute removal and attribute generalization.
Attribute removal is based on the following rule: If there is a large set of distinct values
for an attribute of the initial working relation, but either (case 1) there is no generalization
operator on the attribute (e.g., there is no concept hierarchy defined for the attribute), or
(case 2) its higher-level concepts are expressed in terms of other attributes, then the attribute
should be removed from the working relation.
Let’s examine the reasoning behind this rule. An attribute–value pair represents a
conjunct in a generalized tuple, or rule. The removal of a conjunct eliminates a constraint and thus generalizes the rule. If, as in case 1, there is a large set of distinct values
for an attribute but there is no generalization operator for it, the attribute should be
removed because it cannot be generalized. Preserving it would imply keeping a large
number of disjuncts, which contradicts the goal of generating concise rules. On the
other hand, consider case 2, where the attribute’s higher-level concepts are expressed
in terms of other attributes. For example, suppose that the attribute in question is street,
with higher-level concepts that are represented by the attributes hcity, province or state,
countryi. The removal of street is equivalent to the application of a generalization operator. This rule corresponds to the generalization rule known as dropping condition in the
machine learning literature on learning from examples.
Attribute generalization is based on the following rule: If there is a large set of distinct
values for an attribute in the initial working relation, and there exists a set of generalization
operators on the attribute, then a generalization operator should be selected and applied

170

Chapter 4 Data Warehousing and Online Analytical Processing

to the attribute. This rule is based on the following reasoning. Use of a generalization
operator to generalize an attribute value within a tuple, or rule, in the working relation
will make the rule cover more of the original data tuples, thus generalizing the concept it
represents. This corresponds to the generalization rule known as climbing generalization
trees in learning from examples, or concept tree ascension.
Both rules–attribute removal and attribute generalization–claim that if there is a large
set of distinct values for an attribute, further generalization should be applied. This
raises the question: How large is “a large set of distinct values for an attribute” considered
to be?
Depending on the attributes or application involved, a user may prefer some
attributes to remain at a rather low abstraction level while others are generalized to
higher levels. The control of how high an attribute should be generalized is typically
quite subjective. The control of this process is called attribute generalization control.
If the attribute is generalized “too high,” it may lead to overgeneralization, and the
resulting rules may not be very informative.
On the other hand, if the attribute is not generalized to a “sufficiently high level,”
then undergeneralization may result, where the rules obtained may not be informative
either. Thus, a balance should be attained in attribute-oriented generalization. There are
many possible ways to control a generalization process. We will describe two common
approaches and illustrate how they work.
The first technique, called attribute generalization threshold control, either sets one
generalization threshold for all of the attributes, or sets one threshold for each attribute.
If the number of distinct values in an attribute is greater than the attribute threshold,
further attribute removal or attribute generalization should be performed. Data mining
systems typically have a default attribute threshold value generally ranging from 2 to 8
and should allow experts and users to modify the threshold values as well. If a user feels
that the generalization reaches too high a level for a particular attribute, the threshold
can be increased. This corresponds to drilling down along the attribute. Also, to further
generalize a relation, the user can reduce an attribute’s threshold, which corresponds to
rolling up along the attribute.
The second technique, called generalized relation threshold control, sets a threshold
for the generalized relation. If the number of (distinct) tuples in the generalized relation
is greater than the threshold, further generalization should be performed. Otherwise,
no further generalization should be performed. Such a threshold may also be preset in
the data mining system (usually within a range of 10 to 30), or set by an expert or user,
and should be adjustable. For example, if a user feels that the generalized relation is too
small, he or she can increase the threshold, which implies drilling down. Otherwise, to
further generalize a relation, the threshold can be reduced, which implies rolling up.
These two techniques can be applied in sequence: First apply the attribute threshold
control technique to generalize each attribute, and then apply relation threshold control
to further reduce the size of the generalized relation. No matter which generalization
control technique is applied, the user should be allowed to adjust the generalization
thresholds in order to obtain interesting concept descriptions.
In many database-oriented induction processes, users are interested in obtaining
quantitative or statistical information about the data at different abstraction levels.

4.5 Data Generalization by Attribute-Oriented Induction

171

Thus, it is important to accumulate count and other aggregate values in the induction
process. Conceptually, this is performed as follows. The aggregate function, count(), is
associated with each database tuple. Its value for each tuple in the initial working relation
is initialized to 1. Through attribute removal and attribute generalization, tuples within
the initial working relation may be generalized, resulting in groups of identical tuples. In
this case, all of the identical tuples forming a group should be merged into one tuple.
The count of this new, generalized tuple is set to the total number of tuples from the
initial working relation that are represented by (i.e., merged into) the new generalized
tuple. For example, suppose that by attribute-oriented induction, 52 data tuples from
the initial working relation are all generalized to the same tuple, T. That is, the generalization of these 52 tuples resulted in 52 identical instances of tuple T. These 52 identical
tuples are merged to form one instance of T, with a count that is set to 52. Other popular
aggregate functions that could also be associated with each tuple include sum() and avg().
For a given generalized tuple, sum() contains the sum of the values of a given numeric
attribute for the initial working relation tuples making up the generalized tuple. Suppose
that tuple T contained sum(units sold ) as an aggregate function. The sum value for tuple
T would then be set to the total number of units sold for each of the 52 tuples. The
aggregate avg() (average) is computed according to the formula avg() = sum()/count().
Example 4.12 Attribute-oriented induction. Here we show how attribute-oriented induction is performed on the initial working relation of Table 4.5. For each attribute of the relation,
the generalization proceeds as follows:
1. name: Since there are a large number of distinct values for name and there is no
generalization operation defined on it, this attribute is removed.
2. gender: Since there are only two distinct values for gender, this attribute is retained
and no generalization is performed on it.
3. major: Suppose that a concept hierarchy has been defined that allows the attribute
major to be generalized to the values {arts&sciences, engineering, business}. Suppose
also that the attribute generalization threshold is set to 5, and that there are more than
20 distinct values for major in the initial working relation. By attribute generalization
and attribute generalization control, major is therefore generalized by climbing the
given concept hierarchy.
4. birth place: This attribute has a large number of distinct values; therefore, we would
like to generalize it. Suppose that a concept hierarchy exists for birth place, defined as
“city < province or state < country.” If the number of distinct values for country in
the initial working relation is greater than the attribute generalization threshold, then
birth place should be removed, because even though a generalization operator exists
for it, the generalization threshold would not be satisfied. If, instead, the number
of distinct values for country is less than the attribute generalization threshold, then
birth place should be generalized to birth country.
5. birth date: Suppose that a hierarchy exists that can generalize birth date to age and
age to age range, and that the number of age ranges (or intervals) is small with

172

Chapter 4 Data Warehousing and Online Analytical Processing

Table 4.6 Generalized Relation Obtained by Attribute-Oriented Induction on Table 4.5’s Data
gender

major

birth country

age range

residence city

gpa

count

M
F
···

Science
Science
···

Canada
Foreign
···

20 – 25
25 – 30
···

Richmond
Burnaby
···

very good
excellent
···

16
22
···

respect to the attribute generalization threshold. Generalization of birth date should
therefore take place.
6. residence: Suppose that residence is defined by the attributes number, street, residence city, residence province or state, and residence country. The number of distinct
values for number and street will likely be very high, since these concepts are quite low
level. The attributes number and street should therefore be removed so that residence
is then generalized to residence city, which contains fewer distinct values.
7. phone#: As with the name attribute, phone# contains too many distinct values and
should therefore be removed in generalization.
8. gpa: Suppose that a concept hierarchy exists for gpa that groups values for grade
point average into numeric intervals like {3.75–4.0, 3.5–3.75, . . . }, which in turn are
grouped into descriptive values such as {“excellent”, “very good”, . . . }. The attribute
can therefore be generalized.
The generalization process will result in groups of identical tuples. For example, the
first two tuples of Table 4.5 both generalize to the same identical tuple (namely, the first
tuple shown in Table 4.6). Such identical tuples are then merged into one, with their
counts accumulated. This process leads to the generalized relation shown in Table 4.6.
Based on the vocabulary used in OLAP, we may view count( ) as a measure, and the
remaining attributes as dimensions. Note that aggregate functions, such as sum( ), may be
applied to numeric attributes (e.g., salary and sales). These attributes are referred to as
measure attributes.

4.5.2 Efficient Implementation of Attribute-Oriented Induction
“How is attribute-oriented induction actually implemented?” Section 4.5.1 provided an
introduction to attribute-oriented induction. The general procedure is summarized in
Figure 4.18. The efficiency of this algorithm is analyzed as follows:
Step 1 of the algorithm is essentially a relational query to collect the task-relevant data
into the working relation, W . Its processing efficiency depends on the query processing methods used. Given the successful implementation and commercialization
of database systems, this step is expected to have good performance.
Step 2 collects statistics on the working relation. This requires scanning the relation
at most once. The cost for computing the minimum desired level and determining
the mapping pairs, (v, v 0 ), for each attribute is dependent on the number of distinct

4.5 Data Generalization by Attribute-Oriented Induction

173

Algorithm: Attribute-oriented induction. Mining generalized characteristics in a relational
database given a user’s data mining request.
Input:
DB, a relational database;
DMQuery, a data mining query;
a list, a list of attributes (containing attributes, ai );
Gen(ai ), a set of concept hierarchies or generalization operators on attributes, ai ;
a gen thresh(ai ), attribute generalization thresholds for each ai .
Output: P, a Prime generalized relation.
Method:
1. W ← get task relevant data (DMQuery, DB); // Let W , the working relation, hold the
task-relevant data.
2. prepare for generalization (W ); // This is implemented as follows.
(a) Scan W and collect the distinct values for each attribute, ai . (Note: If W is very large,
this may be done by examining a sample of W .)
(b) For each attribute ai , determine whether ai should be removed. If not, compute its
minimum desired level Li based on its given or default attribute threshold, and
determine the mapping pairs (v, v 0 ), where v is a distinct value of ai in W , and v 0 is its
corresponding generalized value at level Li .
3. P ← generalization (W ),
The Prime generalized relation, P, is derived by replacing each value v in W by its
corresponding v 0 in the mapping while accumulating count and computing any other
aggregate values.
This step can be implemented efficiently using either of the two following variations:
(a) For each generalized tuple, insert the tuple into a sorted prime relation P by a binary
search: if the tuple is already in P, simply increase its count and other aggregate
values accordingly; otherwise, insert it into P.
(b) Since in most cases the number of distinct values at the prime relation level is small,
the prime relation can be coded as an m-dimensional array, where m is the number of
attributes in P, and each dimension contains the corresponding generalized attribute
values. Each array element holds the corresponding count and other aggregation
values, if any. The insertion of a generalized tuple is performed by measure
aggregation in the corresponding array element.

Figure 4.18 Basic algorithm for attribute-oriented induction.

174

Chapter 4 Data Warehousing and Online Analytical Processing

values for each attribute and is smaller than |W |, the number of tuples in the working relation. Notice that it may not be necessary to scan the working relation once,
since if the working relation is large, a sample of such a relation will be sufficient to
get statistics and determine which attributes should be generalized to a certain high
level and which attributes should be removed. Moreover, such statistics may also be
obtained in the process of extracting and generating a working relation in Step 1.
Step 3 derives the prime relation, P. This is performed by scanning each tuple in
the working relation and inserting generalized tuples into P. There are a total of |W |
tuples in W and p tuples in P. For each tuple, t, in W , we substitute its attribute values
based on the derived mapping pairs. This results in a generalized tuple, t 0 . If variation
(a) in Figure 4.18 is adopted, each t 0 takes O(log p) to find the location for the count
increment or tuple insertion. Thus, the total time complexity is O(|W | × log p) for
all of the generalized tuples. If variation (b) is adopted, each t 0 takes O(1) to find the
tuple for the count increment. Thus, the overall time complexity is O(N ) for all of
the generalized tuples.
Many data analysis tasks need to examine a good number of dimensions or attributes.
This may involve dynamically introducing and testing additional attributes rather than
just those specified in the mining query. Moreover, a user with little knowledge of the
truly relevant data set may simply specify “in relevance to ∗” in the mining query, which
includes all of the attributes in the analysis. Therefore, an advanced–concept description
mining process needs to perform attribute relevance analysis on large sets of attributes
to select the most relevant ones. This analysis may employ correlation measures or tests
of statistical significance, as described in Chapter 3 on data preprocessing.
Example 4.13 Presentation of generalization results. Suppose that attribute-oriented induction was
performed on a sales relation of the AllElectronics database, resulting in the generalized
description of Table 4.7 for sales last year. The description is shown in the form of a
generalized relation. Table 4.6 is another generalized relation example.
Such generalized relations can also be presented in the form of cross-tabulation
forms, various kinds of graphic presentation (e.g., pie charts and bar charts), and
quantitative characteristics rules (i.e., showing how different value combinations are
distributed in the generalized relation).
Table 4.7 Generalized Relation for Last Year’s Sales
location

item

sales (in million dollars)

count (in thousands)

Asia
Europe
North America
Asia
Europe
North America

TV
TV
TV
computer
computer
computer

15
12
28
120
150
200

300
250
450
1000
1200
1800

4.5 Data Generalization by Attribute-Oriented Induction

175

4.5.3 Attribute-Oriented Induction for Class Comparisons
In many applications, users may not be interested in having a single class (or concept) described or characterized, but prefer to mine a description that compares or
distinguishes one class (or concept) from other comparable classes (or concepts).
Class discrimination or comparison (hereafter referred to as class comparison) mines
descriptions that distinguish a target class from its contrasting classes. Notice that the
target and contrasting classes must be comparable in the sense that they share similar
dimensions and attributes. For example, the three classes person, address, and item are
not comparable. However, sales in the last three years are comparable classes, and so are,
for example, computer science students versus physics students.
Our discussions on class characterization in the previous sections handle multilevel
data summarization and characterization in a single class. The techniques developed can
be extended to handle class comparison across several comparable classes. For example,
the attribute generalization process described for class characterization can be modified
so that the generalization is performed synchronously among all the classes compared.
This allows the attributes in all of the classes to be generalized to the same abstraction
levels.
Suppose, for instance, that we are given the AllElectronics data for sales in 2009 and
in 2010 and want to compare these two classes. Consider the dimension location with
abstractions at the city, province or state, and country levels. Data in each class should be
generalized to the same location level. That is, they are all synchronously generalized to
either the city level, the province or state level, or the country level. Ideally, this is more
useful than comparing, say, the sales in Vancouver in 2009 with the sales in the United
States in 2010 (i.e., where each set of sales data is generalized to a different level). The
users, however, should have the option to overwrite such an automated, synchronous
comparison with their own choices, when preferred.
“How is class comparison performed?” In general, the procedure is as follows:
1. Data collection: The set of relevant data in the database is collected by query processing and is partitioned respectively into a target class and one or a set of contrasting
classes.
2. Dimension relevance analysis: If there are many dimensions, then dimension relevance analysis should be performed on these classes to select only the highly relevant
dimensions for further analysis. Correlation or entropy-based measures can be used
for this step (Chapter 3).
3. Synchronous generalization: Generalization is performed on the target class to the
level controlled by a user- or expert-specified dimension threshold, which results in
a prime target class relation. The concepts in the contrasting class(es) are generalized to the same level as those in the prime target class relation, forming the prime
contrasting class(es) relation.
4. Presentation of the derived comparison: The resulting class comparison description
can be visualized in the form of tables, graphs, and rules. This presentation usually
includes a “contrasting” measure such as count% (percentage count) that reflects the

176

Chapter 4 Data Warehousing and Online Analytical Processing

comparison between the target and contrasting classes. The user can adjust the comparison description by applying drill-down, roll-up, and other OLAP operations to
the target and contrasting classes, as desired.
The preceding discussion outlines a general algorithm for mining comparisons
in databases. In comparison with characterization, the previous algorithm involves
synchronous generalization of the target class with the contrasting classes, so that classes
are simultaneously compared at the same abstraction levels.
Example 4.14 mines a class comparison describing the graduate and undergraduate
students at Big University.
Example 4.14 Mining a class comparison. Suppose that you would like to compare the general properties of the graduate and undergraduate students at Big University, given the attributes
name, gender, major, birth place, birth date, residence, phone#, and gpa.
This data mining task can be expressed in DMQL as follows:
use Big University DB
mine comparison as “grad vs undergrad students”
in relevance to name, gender, major, birth place, birth date, residence,

phone#, gpa
for “graduate students”
where status in “graduate”
versus “undergraduate students”
where status in “undergraduate”
analyze count%
from student

Let’s see how this typical example of a data mining query for mining comparison
descriptions can be processed.
First, the query is transformed into two relational queries that collect two sets of taskrelevant data: one for the initial target-class working relation and the other for the initial
contrasting-class working relation, as shown in Tables 4.8 and 4.9. This can also be viewed
as the construction of a data cube, where the status {graduate, undergraduate} serves as
one dimension, and the other attributes form the remaining dimensions.
Second, dimension relevance analysis can be performed, when necessary, on the two
classes of data. After this analysis, irrelevant or weakly relevant dimensions (e.g., name,
gender, birth place, residence, and phone#) are removed from the resulting classes. Only
the highly relevant attributes are included in the subsequent analysis.
Third, synchronous generalization is performed on the target class to the levels controlled by user- or expert-specified dimension thresholds, forming the prime target class
relation. The contrasting class is generalized to the same levels as those in the prime
target class relation, forming the prime contrasting class(es) relation, as presented in
Tables 4.10 and 4.11. In comparison with undergraduate students, graduate students
tend to be older and have a higher GPA in general.

4.5 Data Generalization by Attribute-Oriented Induction

177

Table 4.8 Initial Working Relations: The Target Class (Graduate Students)
name

gender major birth place

birth date residence

phone#

gpa

Jim Woodman
Scott Lachance
Laura Lee
···

M
M
F
···

12-8-76
7-28-75
8-25-70
···

687-4598
253-9106
420-5232
···

3.67
3.70
3.83
···

CS
CS
Physics
···

Vancouver, BC, Canada
Montreal, Que, Canada
Seattle, WA, USA
···

3511 Main St., Richmond
345 1st Ave., Vancouver
125 Austin Ave., Burnaby
···

Table 4.9 Initial Working Relations: The Contrasting Class (Undergraduate Students)
name

gender major

Bob Schumann M
Amy Eau
F
···
···

birth place

birth date residence

Chemistry Calgary, Alt, Canada 1-10-78
Biology
Golden, BC, Canada 3-30-76
···
···
···

phone# gpa

2642 Halifax St., Burnaby 294-4291 2.96
463 Sunset Cres., Vancouver 681-5417 3.52
···
···
···

Table 4.10 Prime Generalized Relation for the Target Class (Graduate Students)
major

age range

gpa

count%

Science
Science
Science
···
Business

21...25
26...30
over 30
···
over 30

good
good
very good
···
excellent

5.53
5.02
5.86
···
4.68

Table 4.11 Prime Generalized Relation for the Contrasting Class (Undergraduate Students)
major

age range

gpa

count%

Science
Science
···
Science
···
Business

16...20
16...20
···
26...30
···
over 30

fair
good
···
good
···
excellent

5.53
4.53
···
2.32
···
0.68

Finally, the resulting class comparison is presented in the form of tables, graphs,
and/or rules. This visualization includes a contrasting measure (e.g., count%) that compares the target class and the contrasting class. For example, 5.02% of the graduate
students majoring in science are between 26 and 30 years old and have a “good” GPA,
while only 2.32% of undergraduates have these same characteristics. Drilling and other

178

Chapter 4 Data Warehousing and Online Analytical Processing

OLAP operations may be performed on the target and contrasting classes as deemed
necessary by the user in order to adjust the abstraction levels of the final description.
In summary, attribute-oriented induction for data characterization and generalization provides an alternative data generalization method in comparison to the data cube
approach. It is not confined to relational data because such an induction can be performed on spatial, multimedia, sequence, and other kinds of data sets. In addition, there
is no need to precompute a data cube because generalization can be performed online
upon receiving a user’s query.
Moreover, automated analysis can be added to such an induction process to automatically filter out irrelevant or unimportant attributes. However, because attributeoriented induction automatically generalizes data to a higher level, it cannot efficiently
support the process of drilling down to levels deeper than those provided in the generalized relation. The integration of data cube technology with attribute-oriented induction
may provide a balance between precomputation and online computation. This would
also support fast online computation when it is necessary to drill down to a level deeper
than that provided in the generalized relation.

4.6

Summary
A data warehouse is a subject-oriented, integrated, time-variant, and nonvolatile data
collection organized in support of management decision making. Several factors
distinguish data warehouses from operational databases. Because the two systems
provide quite different functionalities and require different kinds of data, it is
necessary to maintain data warehouses separately from operational databases.
Data warehouses often adopt a three-tier architecture. The bottom tier is a warehouse database server, which is typically a relational database system. The middle tier
is an OLAP server, and the top tier is a client that contains query and reporting tools.
A data warehouse contains back-end tools and utilities for populating and refreshing the warehouse. These cover data extraction, data cleaning, data transformation,
loading, refreshing, and warehouse management.
Data warehouse metadata are data defining the warehouse objects. A metadata
repository provides details regarding the warehouse structure, data history, the algorithms used for summarization, mappings from the source data to the warehouse
form, system performance, and business terms and issues.
A multidimensional data model is typically used for the design of corporate data
warehouses and departmental data marts. Such a model can adopt a star schema,
snowflake schema, or fact constellation schema. The core of the multidimensional
model is the data cube, which consists of a large set of facts (or measures) and a
number of dimensions. Dimensions are the entities or perspectives with respect to
which an organization wants to keep records and are hierarchical in nature.

4.6 Summary

179

A data cube consists of a lattice of cuboids, each corresponding to a different degree
of summarization of the given multidimensional data.
Concept hierarchies organize the values of attributes or dimensions into gradual
abstraction levels. They are useful in mining at multiple abstraction levels.
Online analytical processing can be performed in data warehouses/marts using
the multidimensional data model. Typical OLAP operations include roll-up, and
drill-(down, across, through), slice-and-dice, and pivot (rotate), as well as statistical
operations such as ranking and computing moving averages and growth rates. OLAP
operations can be implemented efficiently using the data cube structure.
Data warehouses are used for information processing (querying and reporting),
analytical processing (which allows users to navigate through summarized and
detailed data by OLAP operations), and data mining (which supports knowledge
discovery). OLAP-based data mining is referred to as multidimensional data mining (also known as exploratory multidimensional data mining, online analytical
mining, or OLAM). It emphasizes the interactive and exploratory nature of data
mining.
OLAP servers may adopt a relational OLAP (ROLAP), a multidimensional OLAP
(MOLAP), or a hybrid OLAP (HOLAP) implementation. A ROLAP server uses an
extended relational DBMS that maps OLAP operations on multidimensional data to
standard relational operations. A MOLAP server maps multidimensional data views
directly to array structures. A HOLAP server combines ROLAP and MOLAP. For
example, it may use ROLAP for historic data while maintaining frequently accessed
data in a separate MOLAP store.
Full materialization refers to the computation of all of the cuboids in the lattice
defining a data cube. It typically requires an excessive amount of storage space,
particularly as the number of dimensions and size of associated concept hierarchies
grow. This problem is known as the curse of dimensionality. Alternatively, partial
materialization is the selective computation of a subset of the cuboids or subcubes
in the lattice. For example, an iceberg cube is a data cube that stores only those
cube cells that have an aggregate value (e.g., count) above some minimum support
threshold.
OLAP query processing can be made more efficient with the use of indexing techniques. In bitmap indexing, each attribute has its own bitmap index table. Bitmap
indexing reduces join, aggregation, and comparison operations to bit arithmetic.
Join indexing registers the joinable rows of two or more relations from a relational
database, reducing the overall cost of OLAP join operations. Bitmapped join indexing, which combines the bitmap and join index methods, can be used to further
speed up OLAP query processing.
Data generalization is a process that abstracts a large set of task-relevant data
in a database from a relatively low conceptual level to higher conceptual levels. Data generalization approaches include data cube-based data aggregation and

180

Chapter 4 Data Warehousing and Online Analytical Processing

attribute-oriented induction. Concept description is the most basic form of descriptive data mining. It describes a given set of task-relevant data in a concise and
summarative manner, presenting interesting general properties of the data. Concept
(or class) description consists of characterization and comparison (or discrimination). The former summarizes and describes a data collection, called the target
class, whereas the latter summarizes and distinguishes one data collection, called
the target class, from other data collection(s), collectively called the contrasting
class(es).
Concept characterization can be implemented using data cube (OLAP-based)
approaches and the attribute-oriented induction approach. These are attributeor dimension-based generalization approaches. The attribute-oriented induction
approach consists of the following techniques: data focusing, data generalization by
attribute removal or attribute generalization, count and aggregate value accumulation,
attribute generalization control, and generalization data visualization.
Concept comparison can be performed using the attribute-oriented induction or
data cube approaches in a manner similar to concept characterization. Generalized
tuples from the target and contrasting classes can be quantitatively compared and
contrasted.

4.7

Exercises

4.1 State why, for the integration of multiple heterogeneous information sources, many
companies in industry prefer the update-driven approach (which constructs and uses
data warehouses), rather than the query-driven approach (which applies wrappers and
integrators). Describe situations where the query-driven approach is preferable to the
update-driven approach.
4.2 Briefly compare the following concepts. You may use an example to explain your
point(s).
(a) Snowflake schema, fact constellation, starnet query model
(b) Data cleaning, data transformation, refresh
(c) Discovery-driven cube, multifeature cube, virtual warehouse
4.3 Suppose that a data warehouse consists of the three dimensions time, doctor, and patient,
and the two measures count and charge, where charge is the fee that a doctor charges a
patient for a visit.
(a) Enumerate three classes of schemas that are popularly used for modeling data
warehouses.
(b) Draw a schema diagram for the above data warehouse using one of the schema
classes listed in (a).

4.7 Exercises

181

(c) Starting with the base cuboid [day, doctor, patient], what specific OLAP operations
should be performed in order to list the total fee collected by each doctor in 2010?
(d) To obtain the same list, write an SQL query assuming the data are stored in a relational database with the schema fee (day, month, year, doctor, hospital, patient, count,
charge).
4.4 Suppose that a data warehouse for Big University consists of the four dimensions student, course, semester, and instructor, and two measures count and avg grade. At the
lowest conceptual level (e.g., for a given student, course, semester, and instructor combination), the avg grade measure stores the actual course grade of the student. At higher
conceptual levels, avg grade stores the average grade for the given combination.
(a) Draw a snowflake schema diagram for the data warehouse.
(b) Starting with the base cuboid [student, course, semester, instructor], what specific
OLAP operations (e.g., roll-up from semester to year) should you perform in order
to list the average grade of CS courses for each Big University student.
(c) If each dimension has five levels (including all), such as “student < major < status <
university < all”, how many cuboids will this cube contain (including the base and
apex cuboids)?
4.5 Suppose that a data warehouse consists of the four dimensions date, spectator, location,
and game, and the two measures count and charge, where charge is the fare that a spectator pays when watching a game on a given date. Spectators may be students, adults, or
seniors, with each category having its own charge rate.
(a) Draw a star schema diagram for the data warehouse.
(b) Starting with the base cuboid [date, spectator, location, game], what specific OLAP
operations should you perform in order to list the total charge paid by student
spectators at GM Place in 2010?
(c) Bitmap indexing is useful in data warehousing. Taking this cube as an example,
briefly discuss advantages and problems of using a bitmap index structure.
4.6 A data warehouse can be modeled by either a star schema or a snowflake schema. Briefly
describe the similarities and the differences of the two models, and then analyze their
advantages and disadvantages with regard to one another. Give your opinion of which
might be more empirically useful and state the reasons behind your answer.
4.7 Design a data warehouse for a regional weather bureau. The weather bureau has about
1000 probes, which are scattered throughout various land and ocean locations in the
region to collect basic weather data, including air pressure, temperature, and precipitation at each hour. All data are sent to the central station, which has collected such
data for more than 10 years. Your design should facilitate efficient querying and online
analytical processing, and derive general weather patterns in multidimensional space.
4.8 A popular data warehouse implementation is to construct a multidimensional database,
known as a data cube. Unfortunately, this may often generate a huge, yet very sparse,
multidimensional matrix.

182

Chapter 4 Data Warehousing and Online Analytical Processing

(a) Present an example illustrating such a huge and sparse data cube.
(b) Design an implementation method that can elegantly overcome this sparse matrix
problem. Note that you need to explain your data structures in detail and discuss
the space needed, as well as how to retrieve data from your structures.
(c) Modify your design in (b) to handle incremental data updates. Give the reasoning
behind your new design.
4.9 Regarding the computation of measures in a data cube:
(a) Enumerate three categories of measures, based on the kind of aggregate functions
used in computing a data cube.
(b) For a data cube with the three dimensions time, location, and item, which category
does the function variance belong to? Describe how to compute it if the cube is
partitioned into many chunks.
P
2
Hint: The formula for computing variance is N1 N
i=1 (xi − x¯i ) , where x¯i is the
average of xi s.
(c) Suppose the function is “top 10 sales.” Discuss how to efficiently compute this
measure in a data cube.
4.10 Suppose a company wants to design a data warehouse to facilitate the analysis of moving
vehicles in an online analytical processing manner. The company registers huge amounts
of auto movement data in the format of (Auto ID, location, speed, time). Each Auto ID
represents a vehicle associated with information (e.g., vehicle category, driver category),
and each location may be associated with a street in a city. Assume that a street map is
available for the city.
(a) Design such a data warehouse to facilitate effective online analytical processing in
multidimensional space.
(b) The movement data may contain noise. Discuss how you would develop a method
to automatically discover data records that were likely erroneously registered in the
data repository.
(c) The movement data may be sparse. Discuss how you would develop a method that
constructs a reliable data warehouse despite the sparsity of data.
(d) If you want to drive from A to B starting at a particular time, discuss how a system
may use the data in this warehouse to work out a fast route.
4.11 Radio-frequency identification is commonly used to trace object movement and perform inventory control. An RFID reader can successfully read an RFID tag from
a limited distance at any scheduled time. Suppose a company wants to design a data
warehouse to facilitate the analysis of objects with RFID tags in an online analytical processing manner. The company registers huge amounts of RFID data in the format of
(RFID, at location, time), and also has some information about the objects carrying the
RFID tag, for example, (RFID, product name, product category, producer, date produced,
price).
(a) Design a data warehouse to facilitate effective registration and online analytical
processing of such data.

4.7 Exercises

183

(b) The RFID data may contain lots of redundant information. Discuss a method
that maximally reduces redundancy during data registration in the RFID data
warehouse.
(c) The RFID data may contain lots of noise such as missing registration and misread
IDs. Discuss a method that effectively cleans up the noisy data in the RFID data
warehouse.
(d) You may want to perform online analytical processing to determine how many TV
sets were shipped from the LA seaport to BestBuy in Champaign, IL, by month,
brand, and price range. Outline how this could be done efficiently if you were to
store such RFID data in the warehouse.
(e) If a customer returns a jug of milk and complains that is has spoiled before its expiration date, discuss how you can investigate such a case in the warehouse to find out
what the problem is, either in shipping or in storage.
4.12 In many applications, new data sets are incrementally added to the existing large
data sets. Thus, an important consideration is whether a measure can be computed
efficiently in an incremental manner. Use count, standard deviation, and median as
examples to show that a distributive or algebraic measure facilitates efficient incremental
computation, whereas a holistic measure does not.
4.13 Suppose that we need to record three measures in a data cube: min(), average(), and
median(). Design an efficient computation and storage method for each measure given
that the cube allows data to be deleted incrementally (i.e., in small portions at a time)
from the cube.
4.14 In data warehouse technology, a multiple dimensional view can be implemented by
a relational database technique (ROLAP), by a multidimensional database technique
(MOLAP), or by a hybrid database technique (HOLAP).
(a) Briefly describe each implementation technique.
(b) For each technique, explain how each of the following functions may be
implemented:
i. The generation of a data warehouse (including aggregation)
ii. Roll-up
iii. Drill-down
iv. Incremental updating
(c) Which implementation techniques do you prefer, and why?
4.15 Suppose that a data warehouse contains 20 dimensions, each with about five levels of
granularity.
(a) Users are mainly interested in four particular dimensions, each having three frequently accessed levels for rolling up and drilling down. How would you design a
data cube structure to support this preference efficiently?
(b) At times, a user may want to drill through the cube to the raw data for one or two
particular dimensions. How would you support this feature?

184

Chapter 4 Data Warehousing and Online Analytical Processing

4.16 A data cube, C, has n dimensions, and each dimension has exactly p distinct values
in the base cuboid. Assume that there are no concept hierarchies associated with the
dimensions.
(a) What is the maximum number of cells possible in the base cuboid?
(b) What is the minimum number of cells possible in the base cuboid?
(c) What is the maximum number of cells possible (including both base cells and
aggregate cells) in the C data cube?
(d) What is the minimum number of cells possible in C?
4.17 What are the differences between the three main types of data warehouse usage: information processing, analytical processing, and data mining? Discuss the motivation behind
OLAP mining (OLAM).

4.8

Bibliographic Notes
There are a good number of introductory-level textbooks on data warehousing and
OLAP technology—for example, Kimball, Ross, Thornthwaite, et al. [KRTM08];
Imhoff, Galemmo, and Geiger [IGG03]; and Inmon [Inm96]. Chaudhuri and Dayal
[CD97] provide an early overview of data warehousing and OLAP technology. A set of
research papers on materialized views and data warehouse implementations were collected in Materialized Views: Techniques, Implementations, and Applications by Gupta
and Mumick [GM99].
The history of decision support systems can be traced back to the 1960s. However,
the proposal to construct large data warehouses for multidimensional data analysis is
credited to Codd [CCS93] who coined the term OLAP for online analytical processing.
The OLAP Council was established in 1995. Widom [Wid95] identified several research
problems in data warehousing. Kimball and Ross [KR02] provide an overview of the
deficiencies of SQL regarding the ability to support comparisons that are common in the
business world, and present a good set of application cases that require data warehousing
and OLAP technology. For an overview of OLAP systems versus statistical databases, see
Shoshani [Sho97].
Gray et al. [GCB+ 97] proposed the data cube as a relational aggregation operator
generalizing group-by, crosstabs, and subtotals. Harinarayan, Rajaraman, and Ullman
[HRU96] proposed a greedy algorithm for the partial materialization of cuboids in the
computation of a data cube. Data cube computation methods have been investigated by
numerous studies such as Sarawagi and Stonebraker [SS94]; Agarwal et al. [AAD+ 96];
Zhao, Deshpande, and Naughton [ZDN97]; Ross and Srivastava [RS97]; Beyer and
Ramakrishnan [BR99]; Han, Pei, Dong, and Wang [HPDW01]; and Xin, Han, Li, and
Wah [XHLW03]. These methods are discussed in depth in Chapter 5.
The concept of iceberg queries was first introduced in Fang, Shivakumar, GarciaMolina et al. [FSGM+ 98]. The use of join indices to speed up relational query processing
was proposed by Valduriez [Val87]. O’Neil and Graefe [OG95] proposed a bitmapped

4.8 Bibliographic Notes

185

join index method to speed up OLAP-based query processing. A discussion of the performance of bitmapping and other nontraditional index techniques is given in O’Neil
and Quass [OQ97].
For work regarding the selection of materialized cuboids for efficient OLAP query
processing, see, for example, Chaudhuri and Dayal [CD97]; Harinarayan, Rajaraman,
and Ullman [HRU96]; and Sristava et al. [SDJL96]. Methods for cube size estimation
can be found in Deshpande et al. [DNR+ 97], Ross and Srivastava [RS97], and Beyer and
Ramakrishnan [BR99]. Agrawal, Gupta, and Sarawagi [AGS97] proposed operations for
modeling multidimensional databases. Methods for answering queries quickly by online
aggregation are described in Hellerstein, Haas, and Wang [HHW97] and Hellerstein
et al. [HAC+ 99]. Techniques for estimating the top N queries are proposed in Carey
and Kossman [CK98] and Donjerkovic and Ramakrishnan [DR99]. Further studies on
intelligent OLAP and discovery-driven exploration of data cubes are presented in the
bibliographic notes in Chapter 5.

This page intentionally left blank

5

Data Cube Technology

Data warehouse systems provide online analytical processing (OLAP) tools for interactive
analysis of multidimensional data at varied granularity levels. OLAP tools typically use
the data cube and a multidimensional data model to provide flexible access to summarized data. For example, a data cube can store precomputed measures (like count() and
total sales()) for multiple combinations of data dimensions (like item, region, and customer).
Users can pose OLAP queries on the data. They can also interactively explore the data
in a multidimensional way through OLAP operations like drill-down (to see more specialized data such as total sales per city) or roll-up (to see the data at a more generalized
level such as total sales per country).
Although the data cube concept was originally intended for OLAP, it is also useful for data mining. Multidimensional data mining is an approach to data mining
that integrates OLAP-based data analysis with knowledge discovery techniques. It is
also known as exploratory multidimensional data mining and online analytical mining
(OLAM). It searches for interesting patterns by exploring the data in multidimensional
space. This gives users the freedom to dynamically focus on any subset of interesting
dimensions. Users can interactively drill down or roll up to varying abstraction levels to
find classification models, clusters, predictive rules, and outliers.
This chapter focuses on data cube technology. In particular, we study methods for
data cube computation and methods for multidimensional data analysis. Precomputing a data cube (or parts of a data cube) allows for fast accessing of summarized data.
Given the high dimensionality of most data, multidimensional analysis can run into
performance bottlenecks. Therefore, it is important to study data cube computation
techniques. Luckily, data cube technology provides many effective and scalable methods for cube computation. Studying these methods will also help in our understanding
and further development of scalable methods for other data mining tasks such as the
discovery of frequent patterns (Chapters 6 and 7).
We begin in Section 5.1 with preliminary concepts for cube computation. These summarize the data cube notion as a lattice of cuboids, and describe basic forms of cube
materialization. General strategies for cube computation are given. Section 5.2 follows
with an in-depth look at specific methods for data cube computation. We study both
full materialization (i.e., where all the cuboids representing a data cube are precomputed
Data Mining: Concepts and Techniques
c 2012 Elsevier Inc. All rights reserved.

187

188

